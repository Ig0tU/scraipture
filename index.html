<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IEP Assistant Pro - v2.0 Production Ready</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Marked for Markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- PapaParse for CSV handling -->
    <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
    <script>
        // Tailwind Configuration (v3 syntax)
        tailwind.config = {
            darkMode: 'class', // Enable dark mode based on class
            theme: {
                extend: {
                    colors: {
                        primary: { DEFAULT: '#5D5CDE', light: 'rgba(93, 92, 222, 0.1)', dark: 'rgba(93, 92, 222, 0.2)', hover: '#4F46E5' },
                        secondary: '#4F46E5',
                        accent: { DEFAULT: '#8B5CF6', hover: '#7C3AED' },
                        danger: { DEFAULT: '#EF4444', light: 'rgba(239, 68, 68, 0.1)', hover: '#DC2626' },
                        success: { DEFAULT: '#10B981', light: 'rgba(16, 185, 129, 0.1)', hover: '#059669' },
                        warning: { DEFAULT: '#F59E0B', light: 'rgba(245, 158, 11, 0.1)', hover: '#D97706' },
                        info: { DEFAULT: '#3B82F6', light: 'rgba(59, 130, 246, 0.1)' },
                        'base-100': '#FFFFFF', 'base-200': '#F3F4F6', 'base-300': '#E5E7EB',
                        'base-content': '#1F2937',
                        'dark-100': '#111827', 'dark-200': '#1F2937', 'dark-300': '#374151',
                        'dark-content': '#D1D5DB',
                    },
                    animation: {
                        'spin-fast': 'spin 1s linear infinite',
                        'fade-in': 'fadeIn 0.3s ease-out forwards',
                        'fade-out': 'fadeOut 0.3s ease-in forwards',
                        'slide-up': 'slideUp 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards',
                        'toast-in': 'toastIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards',
                        'toast-out': 'toastOut 0.5s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards',
                    },
                    keyframes: {
                        fadeIn: { '0%': { opacity: 0 }, '100%': { opacity: 1 } },
                        fadeOut: { '0%': { opacity: 1 }, '100%': { opacity: 0 } },
                        slideUp: { '0%': { transform: 'translateY(20px)', opacity: 0 }, '100%': { transform: 'translateY(0)', opacity: 1 } },
                        toastIn: { '0%': { transform: 'translateY(100%)', opacity: 0 }, '100%': { transform: 'translateY(0)', opacity: 1 } },
                        toastOut: { '0%': { transform: 'translateY(0)', opacity: 1 }, '100%': { transform: 'translateY(100%)', opacity: 0 } },
                    }
                }
            },
            plugins: [],
        }
    </script>
    <style>
        /* Base styles & Custom Scrollbar */
        body { scroll-behavior: smooth; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #c5c5c5; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        .dark ::-webkit-scrollbar-track { background: #2d3748; }
        .dark ::-webkit-scrollbar-thumb { background: #4a5568; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #718096; }

        /* Multi-select & Textarea */
        select[multiple] option:checked { background-color: #e0e7ff; color: #3730a3; }
        .dark select[multiple] option:checked { background-color: #3730a3; color: #e0e7ff; }
        textarea { max-height: 150px; overflow-y: auto; }

        /* Modal Styles */
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; align-items: center; justify-content: center; z-index: 50; padding: 1rem; animation: fadeIn 0.2s ease-out; }
        .modal-content { background-color: var(--color-base-100); padding: 1.5rem; border-radius: 0.5rem; width: 100%; max-width: 600px; max-height: 90vh; overflow-y: auto; animation: slideUp 0.3s ease-out; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        .dark .modal-content { background-color: var(--color-dark-200); }

        /* Toast Notification Styles */
        #toast-container { position: fixed; bottom: 1rem; right: 1rem; z-index: 100; display: flex; flex-direction: column; gap: 0.5rem; max-width: 350px; }
        .toast { padding: 0.75rem 1rem; border-radius: 0.375rem; color: white; font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); animation: toast-in 0.5s; }
        .toast.fade-out { animation: toastOut 0.5s forwards; }
        .toast-success { background-color: #10B981; } .toast-error { background-color: #EF4444; }
        .toast-warning { background-color: #F59E0B; color: #1F2937; } .toast-info { background-color: #3B82F6; }
        .toast svg { flex-shrink: 0; }

        /* Utility Classes */
        .hover-lift { transition: transform 0.15s ease-in-out, box-shadow 0.15s ease-in-out; }
        .hover-lift:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        *:focus-visible { outline: 3px solid var(--color-accent-default); outline-offset: 2px; border-radius: 4px; }
        .button-spinner { width: 1em; height: 1em; border: 2px solid currentColor; border-right-color: transparent; border-radius: 50%; display: inline-block; animation: spin 0.6s linear infinite; margin-left: 0.5em; }
        .chat-bubble { word-break: break-word; } /* Prevent long unbroken strings from overflowing */
        .copy-btn { position: absolute; top: 6px; right: 6px; opacity: 0; transition: opacity 0.2s; cursor: pointer; background-color: rgba(0,0,0,0.1); border-radius: 4px; padding: 2px; }
        .group:hover .copy-btn { opacity: 0.7; } .copy-btn:hover { opacity: 1; background-color: rgba(0,0,0,0.2); }
        .dark .copy-btn { background-color: rgba(255,255,255,0.1); } .dark .copy-btn:hover { background-color: rgba(255,255,255,0.2); }

        /* Slash Commands Menu - FIXED POSITIONING */
        .slash-menu {
            position: absolute;
            z-index: 100;
            background-color: white;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            width: 100%;
            max-height: 16rem;
            overflow-y: auto;
            top: 100%;
            left: 0;
            margin-top: 4px;
            animation: fadeIn 0.15s ease-out;
        }
        .dark .slash-menu {
            background-color: #1F2937;
            border-color: #374151;
        }
        .slash-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
        }
        .dark .slash-menu-item {
            border-bottom-color: #374151;
        }
        .slash-menu-item:last-child {
            border-bottom: none;
        }
        .slash-menu-item:hover, .slash-menu-item.active {
            background-color: #f3f4f6;
        }
        .dark .slash-menu-item:hover, .dark .slash-menu-item.active {
            background-color: #374151;
        }
        .slash-menu-command {
            font-weight: 600;
            color: #5D5CDE;
            font-size: 0.875rem;
        }
        .slash-menu-description {
            font-size: 0.75rem;
            color: #6b7280;
        }
        .dark .slash-menu-description {
            color: #9ca3af;
        }
        .slash-menu-options {
            font-size: 0.7rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }
        .dark .slash-menu-options {
            color: #6b7280;
        }

        /* PDF Preview Heading Style (applied via JS) */
        .preview-heading { font-size: 1.125rem; font-weight: 600; border-bottom-width: 1px; border-color: var(--color-base-300); padding-bottom: 0.25rem; margin-bottom: 0.75rem; color: var(--color-primary-default); }
        .dark .preview-heading { border-color: var(--color-dark-300); }
    </style>
</head>
<body class="bg-base-200 dark:bg-dark-100 text-base-content dark:text-dark-content min-h-screen font-sans antialiased">

    <div class="container mx-auto px-4 py-6 max-w-7xl"> <!-- Wider container -->
        <header class="text-center mb-6">
             <div class="flex justify-center items-center gap-2 mb-1">
                <svg class="h-9 w-9 text-primary-default" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z" /></svg>
                <h1 class="text-4xl font-bold text-primary-default">IEP Assistant Pro</h1>
             </div>
            <p class="text-lg text-gray-600 dark:text-gray-400">Advanced IEP Creation, Management & AI Collaboration</p>

            <!-- Top Controls -->
            <div class="mt-5 flex flex-wrap justify-center items-center gap-x-4 gap-y-2">
                <div class="inline-flex rounded-md shadow-sm" role="group">
                    <button id="geminiBtn" type="button" aria-label="Use Gemini Model" class="btn-model px-4 py-2 text-sm font-medium rounded-l-lg focus:z-10 focus-visible:ring-2 focus-visible:ring-primary-default focus:outline-none hover-lift">Gemini</button>
                    <button id="huggingfaceBtn" type="button" aria-label="Use Hugging Face Model" class="btn-model px-4 py-2 text-sm font-medium border-t border-b border-r rounded-r-lg focus:z-10 focus-visible:ring-2 focus-visible:ring-primary-default focus:outline-none hover-lift">HuggingFace</button>
                </div>
                <button id="settingsBtn" type="button" aria-label="Open Settings" class="p-2 rounded-full hover:bg-base-300 dark:hover:bg-dark-300 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-default hover-lift">
                    <svg class="h-6 w-6 text-gray-600 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.004.827c-.29.24-.438.613-.431.992a6.759 6.759 0 010 1.255c-.007.378.14.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.29-.24.438-.613.43-.992a6.932 6.932 0 010-1.255c.007-.378-.14-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                </button>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Sidebar -->
            <aside class="lg:col-span-1 rounded-lg bg-base-100 dark:bg-dark-200 p-4 shadow-lg flex flex-col space-y-4 h-[calc(100vh-200px)] overflow-y-auto">
                <h2 class="text-xl font-semibold text-primary-default border-b border-base-300 dark:border-dark-300 pb-2">Management</h2>

                <!-- Add Student Section -->
                <section class="border-b border-base-300 dark:border-dark-300 pb-4">
                     <button id="toggleStudentFormBtn" type="button" aria-controls="studentFormContainer" aria-expanded="false" class="btn btn-primary w-full mb-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg>
                        Add New Student
                    </button>
                    <div id="studentFormContainer" class="hidden space-y-3 border border-base-300 dark:border-dark-300 p-3 rounded-md bg-base-200 dark:bg-dark-300 animate-fade-in">
                        <h3 class="text-md font-semibold">Student Details</h3>
                        <form id="studentForm" class="space-y-3">
                             <!-- Fields with improved labels and validation -->
                             <div><label for="studentName" class="form-label">Student Name <span class="text-danger-default">*</span></label><input type="text" id="studentName" name="studentName" class="form-input" required pattern="\S+.*" title="Name cannot be empty or just spaces"></div>
                             <div><label for="studentGrade" class="form-label">Grade Level <span class="text-danger-default">*</span></label><select id="studentGrade" name="studentGrade" class="form-select" required><option value="">Select Grade</option><option value="K">Kindergarten</option><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option><option value="4">4th</option><option value="5">5th</option><option value="6">6th</option><option value="7">7th</option><option value="8">8th</option><option value="9">9th</option><option value="10">10th</option><option value="11">11th</option><option value="12">12th</option></select></div>
                             <div><label for="disabilityCategory" class="form-label">Disability Category <span class="text-danger-default">*</span></label><select id="disabilityCategory" name="disabilityCategory" class="form-select" required><option value="">Select Category</option><option value="SLD">Specific Learning Disability</option><option value="OHI">Other Health Impairment</option><option value="ASD">Autism Spectrum Disorder</option><option value="ED">Emotional Disturbance</option><option value="SLI">Speech/Language Impairment</option><option value="ID">Intellectual Disability</option><option value="MD">Multiple Disabilities</option><option value="VI">Visual Impairment</option><option value="HI">Hearing Impairment</option><option value="TBI">Traumatic Brain Injury</option></select></div>
                             <div><label for="currentPerformance" class="form-label">Present Levels (PLAAFP)</label><textarea id="currentPerformance" name="currentPerformance" rows="3" class="form-textarea"></textarea></div>
                             <div><label for="specialAccommodations" class="form-label">Accommodations & Mods</label><textarea id="specialAccommodations" name="specialAccommodations" rows="2" class="form-textarea"></textarea></div>
                             <div><label for="servicesSupports" class="form-label">Services & Supports</label><textarea id="servicesSupports" name="servicesSupports" rows="2" class="form-textarea" placeholder="e.g., Speech 2x/wk, OT 1x/wk"></textarea></div>
                            <div class="flex gap-2">
                                <button id="addRecordBtn" type="submit" class="btn btn-success flex-1">Save Student</button>
                                <button id="cancelStudentFormBtn" type="button" class="btn btn-secondary flex-1">Cancel</button>
                            </div>
                        </form>
                    </div>
                </section>

                <!-- Student Selection -->
                <section class="border-b border-base-300 dark:border-dark-300 pb-4">
                    <label for="studentSearch" class="form-label">Find Student</label>
                    <input type="search" id="studentSearch" placeholder="Search students..." class="form-input mb-2">
                    <label for="studentDropdown" class="form-label">Select Student(s)</label>
                    <select id="studentDropdown" class="form-select-multiple" multiple size="5" aria-label="Select one or more students"></select>
                    <div class="mt-2 flex justify-between items-center">
                        <div><button id="selectAllBtn" type="button" class="btn-link">Select All</button><button id="deselectAllBtn" type="button" class="btn-link ml-2">Deselect All</button></div>
                        <span id="selectionStatus" class="text-xs text-gray-500 dark:text-gray-400">No selection</span>
                    </div>
                    <div class="mt-2">
                        <button id="refreshDataBtn" type="button" class="btn btn-secondary w-full flex items-center justify-center gap-1">
                            <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" />
                            </svg>
                            Refresh Data
                        </button>
                    </div>
                </section>

                 <!-- Single Student Focus -->
                <section class="border-b border-base-300 dark:border-dark-300 pb-4">
                    <label for="singleStudentDropdown" class="form-label">Focus on Single Student</label>
                    <select id="singleStudentDropdown" class="form-select mb-2" aria-label="Focus on a single student">
                        <option value="">-- Select a Student --</option>
                    </select>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mb-2">Restricts AI focus to only this student across all tabs.</p>
                </section>

                 <!-- Group Management -->
                <section class="border-b border-base-300 dark:border-dark-300 pb-4">
                    <label for="groupDropdown" class="form-label">Saved Groups</label>
                    <select id="groupDropdown" class="form-select mb-2" aria-label="Select a saved student group"><option value="">-- Select a Group --</option></select>
                     <div id="groupActionsContainer" class="mt-2 space-y-2">
                         <h3 class="text-sm font-medium text-primary-default">Selection Actions</h3>
                         <button id="createGroupBtn" type="button" class="btn btn-accent w-full" disabled>Create Group from Selection</button>
                         <button id="bulkEditBtn" type="button" class="btn btn-secondary w-full" disabled>Bulk Edit Selection</button>
                         <button id="bulkGoalBtn" type="button" class="btn btn-secondary w-full" disabled>Suggest Group Goal</button>
                         <button id="deleteGroupBtn" type="button" class="btn btn-danger w-full" disabled>Delete Selected Group</button>
                    </div>
                </section>

                <!-- Standards -->
                <section>
                    <h3 class="text-lg font-medium mb-1 text-primary-default">IN DOE Standards</h3>
                    <p id="standardSelectionInfo" class="text-xs text-gray-500 dark:text-gray-400 mb-2 hidden">Select standard for <span id="standardContext" class="font-semibold"></span>.</p>
                    <div class="bg-base-100 dark:bg-dark-300 p-3 rounded border border-base-300 dark:border-dark-300 max-h-48 overflow-y-auto">
                        <div class="space-y-1">
                            <!-- Standard items with roles/tabindex -->
                            <div class="standard-item" data-code="IEP-AC-1" role="button" tabindex="0"><p class="font-medium">AC-1: Academic Content</p><p class="text-sm">Measurable progress in core subjects.</p></div>
                            <div class="standard-item" data-code="IEP-SEB-2" role="button" tabindex="0"><p class="font-medium">SEB-2: Social-Emotional Behavior</p><p class="text-sm">Appropriate social interactions & self-regulation.</p></div>
                            <div class="standard-item" data-code="IEP-FL-3" role="button" tabindex="0"><p class="font-medium">FL-3: Functional Living</p><p class="text-sm">Independent living skills.</p></div>
                            <div class="standard-item" data-code="IEP-COM-4" role="button" tabindex="0"><p class="font-medium">COM-4: Communication</p><p class="text-sm">Effective communication skills.</p></div>
                        </div>
                    </div>
                </section>
            </aside>

            <!-- Main Content Area -->
            <section class="lg:col-span-2 rounded-lg bg-base-100 dark:bg-dark-200 p-4 shadow-lg flex flex-col h-[calc(100vh-200px)]">
                <!-- Tabs -->
                <div class="flex border-b border-base-300 dark:border-dark-300 mb-4" role="tablist" aria-label="Main Content Tabs">
                    <button class="tab-btn active" data-tab="chat" role="tab" aria-selected="true" aria-controls="chatPanel">Chat Assistant</button>
                    <button class="tab-btn" data-tab="preview" role="tab" aria-selected="false" aria-controls="previewPanel">IEP Preview</button>
                    <button class="tab-btn" data-tab="history" role="tab" aria-selected="false" aria-controls="historyPanel">Session Logs</button>
                </div>

                <!-- Chat Panel -->
                <div id="chatPanel" role="tabpanel" aria-labelledby="chat-tab" class="flex-grow flex flex-col animate-fade-in">
                    <h3 id="chatHeader" class="text-lg font-semibold mb-2 text-center text-gray-700 dark:text-gray-300">Chat Assistant</h3>
                    <div id="chatMessages" class="flex-grow overflow-y-auto mb-4 space-y-3 p-3 bg-base-200 dark:bg-dark-300 rounded-md border border-base-300 dark:border-dark-300" aria-live="polite">
                        <!-- Initial Welcome Message -->
                        <div class="chat-message assistant flex justify-start mb-3 group animate-fade-in">
                            <div class="flex items-end gap-2">
                                <div class="chat-bubble bg-primary-light dark:bg-primary-dark p-3 rounded-lg rounded-bl-none inline-block max-w-[85%] text-sm leading-relaxed relative">
                                    <p class="font-semibold">👋 Welcome to IEP Assistant Pro!</p>
                                    <p class="mt-1">Select or add a student/group to begin.</p>
                                    <button type="button" class="copy-btn" title="Copy message" aria-label="Copy message"><svg class="h-3 w-3 text-gray-600 dark:text-gray-400" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><use href="#icon-copy"/></svg></button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- Chat Input -->
                    <div class="mt-auto pt-4 border-t border-base-300 dark:border-dark-300">
                        <form id="chatForm" class="flex items-end gap-2">
                            <div class="flex-grow relative">
                                <textarea id="userMessage" placeholder="Ask AI, or type / for commands..." rows="1" class="form-textarea pr-10" style="min-height: 44px;" aria-label="Chat input message"></textarea>
                                <div id="chatStatus" class="absolute right-3 bottom-3 text-sm text-gray-500 dark:text-gray-400 hidden items-center gap-1">
                                    <svg class="animate-spin-fast h-4 w-4 text-primary-default" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                    <span class="status-text">Thinking...</span>
                                </div>
                                
                                <!-- Slash Commands Menu (hidden by default) -->
                                <div id="slashCommandsMenu" class="slash-menu hidden" role="listbox" aria-label="Available commands">
                                    <!-- Will be populated by JS -->
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary h-[44px] flex-shrink-0" aria-label="Send message">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>
                            </button>
                        </form>
                        <div class="flex flex-wrap gap-1.5 mt-2">
                            <button type="button" class="suggestion-btn">Suggest reading goal</button>
                            <button type="button" class="suggestion-btn">Suggest math objective</button>
                            <button type="button" class="suggestion-btn">Explain PLAAFP</button>
                            <button type="button" class="suggestion-btn">Ideas for accommodations</button>
                        </div>
                    </div>
                </div>

                <!-- IEP Preview Panel -->
                 <div id="previewPanel" role="tabpanel" aria-labelledby="preview-tab" class="hidden flex-grow flex flex-col animate-fade-in">
                     <div class="flex-grow overflow-y-auto p-1">
                         <div class="bg-base-200 dark:bg-dark-300 border border-base-300 dark:border-dark-300 rounded-lg p-6 shadow-inner min-h-full">
                            <div id="iepPreviewContent">
                                <div class="text-center mb-6 border-b border-base-300 dark:border-dark-300 pb-3"><h2 class="text-xl font-bold text-primary-default">INDIVIDUALIZED EDUCATION PROGRAM</h2><p class="text-sm text-gray-500 dark:text-gray-400" id="previewStatus">Select a student</p></div>
                                <div id="preview-details"><p class="text-center text-gray-500 dark:text-gray-400 italic mt-6">Select a single student to preview their IEP.</p></div>
                            </div>
                         </div>
                     </div>
                    <div class="mt-4 flex flex-wrap justify-between gap-3 border-t border-base-300 dark:border-dark-300 pt-3">
                        <button id="generateIepBtn" type="button" class="btn btn-accent flex items-center gap-1">
                            <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.894 20.567L16.5 21.75l-.394-1.183a2.25 2.25 0 00-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 001.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 001.423 1.423l1.183.394-1.183.394a2.25 2.25 0 00-1.423 1.423z" />
                            </svg>
                            Generate AI IEP
                        </button>
                        <div class="flex items-center gap-3">
                            <span id="pdfStatus" class="text-sm text-gray-500 dark:text-gray-400 flex items-center gap-1"></span>
                            <button id="previewPdfBtn" type="button" class="btn btn-primary flex items-center gap-1" disabled>
                                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><use href="#icon-pdf" /></svg> Export PDF
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Session Logs Panel -->
                 <div id="historyPanel" role="tabpanel" aria-labelledby="history-tab" class="hidden flex-grow flex flex-col animate-fade-in">
                     <div class="flex-grow overflow-y-auto p-1">
                         <div class="bg-base-200 dark:bg-dark-300 border border-base-300 dark:border-dark-300 rounded-lg p-6 shadow-inner min-h-full">
                            <h3 class="text-lg font-semibold border-b border-base-300 dark:border-dark-300 pb-1 mb-4">Session Logs</h3>
                            <div id="historyContent" class="space-y-4"><p class="text-center text-gray-500 dark:text-gray-400 italic">Select a student or saved group.</p></div>
                        </div>
                     </div>
                    <div class="mt-4 border-t border-base-300 dark:border-dark-300 pt-3 flex justify-end">
                         <button id="clearHistoryBtn" type="button" class="btn btn-danger-outline flex items-center gap-1" disabled>
                             <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><use href="#icon-trash" /></svg> Clear History
                         </button>
                     </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Modals Placeholder -->
    <div id="modalContainer"></div>
    <!-- Toast Notifications Container -->
    <div id="toast-container"></div>

    <!-- SVG Icons Definition -->
    <svg width="0" height="0" style="position:absolute">
      <defs>
        <symbol id="icon-copy" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.03 1.126 0 1.13.094 1.976 1.057 1.976 2.192V7.5m-9 3c0 1.135.845 2.098 1.976 2.192.373.03.748.03 1.126 0 1.13-.094 1.976-1.057 1.976-2.192V10.5M15.75 18c-1.135 0-2.098-.845-2.192-1.976a48.42 48.42 0 010-1.126c.094-1.13 1.057-1.976 2.192-1.976h3c1.135 0 2.098.845 2.192 1.976.03.373.03.748 0 1.126-.094 1.13-1.057 1.976-2.192 1.976h-3z" /></symbol>
        <symbol id="icon-check" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></symbol>
        <symbol id="icon-trash" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></symbol>
        <symbol id="icon-pdf" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></symbol>
        <symbol id="icon-edit" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></symbol>
        <symbol id="icon-chevron-down" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></symbol>
        <symbol id="icon-plus" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></symbol>
        <symbol id="icon-info" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" /></symbol>
        <symbol id="icon-warning" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" /></symbol>
        <symbol id="icon-error" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" /></symbol>
      </defs>
    </svg>

    <script>
        // Wrap in IIFE to avoid polluting global scope
        (function() {
            'use strict';

            // --- Constants ---
            const APP_VERSION = "2.0.2"; // Incremented version for fixes
            const STORAGE_KEY_BASE = 'iepAssistantStatePro_v'; // Base for storage key
            const STORAGE_KEY = STORAGE_KEY_BASE + APP_VERSION.split('.')[0]; // Use major version for storage key stability
            const DEBOUNCE_DELAY = 300; // ms for search debounce
            const TOAST_DURATION = 4000; // ms for toast visibility
            const DISABILITY_MAP = {'SLD':'Specific Learning Disability', 'OHI':'Other Health Impairment', 'ASD':'Autism Spectrum Disorder', 'ED':'Emotional Disturbance', 'SLI':'Speech/Language Impairment', 'ID':'Intellectual Disability', 'MD':'Multiple Disabilities', 'VI':'Visual Impairment', 'HI':'Hearing Impairment', 'TBI':'Traumatic Brain Injury'};
            const GRADE_MAP = {'K':'Kindergarten', '1':'1st', '2':'2nd', '3':'3rd', '4':'4th', '5':'5th', '6':'6th', '7':'7th', '8':'8th', '9':'9th', '10':'10th', '11':'11th', '12':'12th'};
            const API_CONFIG = {
                 huggingface: { apiKey: "hf_token", endpoint: "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2", headers: { "Authorization": "Bearer hf_token", "Content-Type": "application/json" } },
                 gemini: { apiKey: "gemini_token", endpoint: "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent", headers: { "Content-Type": "application/json" } },
                 activeModel: "gemini" // Default, will be overwritten by settings/storage
             };
            const AI_THINKING_MESSAGES = ["Analyzing request...", "Consulting knowledge base...", "Generating response...", "Crafting IEP content...", "Thinking...", "Processing..."];

            // Slash Commands Definition with Synonyms for NLP interpretation
            const SLASH_COMMANDS = [
                { 
                    id: 'gen', 
                    command: '/gen', 
                    description: 'Generate IEP section content', 
                    options: ['plaafp', 'accom', 'services', 'goal', 'complete'],
                    synonyms: ['generate', 'create', 'make', 'craft', 'draft', 'develop', 'write', 'produce', 'compose', 'formulate'],
                    optionSynonyms: {
                        'plaafp': ['present levels', 'present level', 'performance', 'achievement', 'functional performance', 'academic achievement'],
                        'accom': ['accommodations', 'modifications', 'supports', 'adaptations', 'adjust', 'modify'],
                        'services': ['services', 'support', 'therapy', 'intervention', 'assistance', 'aid', 'help'],
                        'goal': ['goals', 'objective', 'target', 'aim', 'outcome', 'expectation', 'smart goal'],
                        'complete': ['complete', 'full', 'entire', 'comprehensive', 'all', 'everything', 'whole', 'total']
                    },
                    execute: (args) => handleGenerateSectionCommand(args[0], args.slice(1).join(' '))
                },
                { 
                    id: 'download', 
                    command: '/download', 
                    description: 'Export data in different formats', 
                    options: ['csv', 'json', 'pdf'],
                    synonyms: ['export', 'save', 'extract', 'output', 'backup', 'get'],
                    optionSynonyms: {
                        'csv': ['csv', 'excel', 'spreadsheet', 'comma'],
                        'json': ['json', 'backup', 'data'],
                        'pdf': ['pdf', 'document', 'print', 'printable']
                    },
                    execute: (args) => {
                        if (args[0] === 'csv') return downloadCsvData();
                        if (args[0] === 'json') return downloadJsonData('all');
                        if (args[0] === 'pdf') return exportToPDF();
                        showToast('Usage: /download [csv|json|pdf]', 'info'); 
                    }
                },
                { 
                    id: 'clear', 
                    command: '/clear', 
                    description: 'Clear data', 
                    options: ['history', 'storage'],
                    synonyms: ['delete', 'remove', 'erase', 'empty', 'clean', 'purge', 'wipe'], 
                    optionSynonyms: {
                        'history': ['history', 'chat', 'conversation', 'messages', 'logs'],
                        'storage': ['storage', 'data', 'all', 'everything', 'everything', 'database', 'all data']
                    },
                    execute: (args) => {
                        if (args[0] === 'history') return handleClearHistory();
                        if (args[0] === 'storage' && confirm('DANGER: Clear ALL saved data? This cannot be undone.')) {
                            localStorage.removeItem(STORAGE_KEY); 
                            window.location.reload(); 
                            return true;
                        }
                        showToast('Usage: /clear [history|storage]', 'info');
                    }
                },
                { 
                    id: 'help', 
                    command: '/help', 
                    description: 'Show available commands and usage', 
                    options: [],
                    synonyms: ['help', 'assistance', 'guide', 'commands', 'instructions', 'documentation', 'info'],
                    execute: () => {
                        const helpText = `**Available Commands:**\n` +
                            `- \`/gen [plaafp|accom|services|goal|complete] [details]\` - Generate IEP content\n` +
                            `- \`/download [csv|json|pdf]\` - Export data\n` +
                            `- \`/clear [history|storage]\` - Clear data (storage deletes ALL data!)\n` +
                            `- \`/help\` - Show this help message`;
                        addMessage('assistant', helpText);
                        return true;
                    }
                }
            ];

            // --- Global State ---
            const appState = {
                students: [],
                studentGroups: [],
                selectedStudentIndexes: [],
                selectedGroupIndex: null,
                activeContext: 'none',
                selectedStandard: null,
                currentChatTarget: null,
                settings: { defaultModel: 'gemini', darkMode: 'system' },
                appVersion: APP_VERSION
            };

            // --- DOM Elements Cache ---
            const $ = (selector) => document.querySelector(selector);
            const $$ = (selector) => document.querySelectorAll(selector);
            const elements = {
                // Main containers & panels
                chatPanel: $('#chatPanel'), previewPanel: $('#previewPanel'), historyPanel: $('#historyPanel'),
                chatMessages: $('#chatMessages'), iepPreviewContent: $('#iepPreviewContent'),
                previewDetails: $('#preview-details'), historyContent: $('#historyContent'),
                modalContainer: $('#modalContainer'), toastContainer: $('#toast-container'),
                // Header & Settings
                chatHeader: $('#chatHeader'), settingsBtn: $('#settingsBtn'),
                geminiBtn: $('#geminiBtn'), huggingfaceBtn: $('#huggingfaceBtn'),
                // Sidebar: Student Form
                toggleStudentFormBtn: $('#toggleStudentFormBtn'), studentFormContainer: $('#studentFormContainer'),
                studentForm: $('#studentForm'), addRecordBtn: $('#addRecordBtn'), cancelStudentFormBtn: $('#cancelStudentFormBtn'),
                // Sidebar: Student/Group Selection
                studentSearch: $('#studentSearch'), studentDropdown: $('#studentDropdown'),
                singleStudentDropdown: $('#singleStudentDropdown'), refreshDataBtn: $('#refreshDataBtn'),
                groupDropdown: $('#groupDropdown'), selectAllBtn: $('#selectAllBtn'), deselectAllBtn: $('#deselectAllBtn'),
                selectionStatus: $('#selectionStatus'),
                // Sidebar: Group Actions
                groupActionsContainer: $('#groupActionsContainer'), createGroupBtn: $('#createGroupBtn'),
                bulkEditBtn: $('#bulkEditBtn'), bulkGoalBtn: $('#bulkGoalBtn'), deleteGroupBtn: $('#deleteGroupBtn'),
                // Sidebar: Standards
                standardSelectionInfo: $('#standardSelectionInfo'), standardContext: $('#standardContext'),
                standardItems: $$('.standard-item'),
                // Chat Input Area
                chatForm: $('#chatForm'), userMessageInput: $('#userMessage'), chatStatus: $('#chatStatus'),
                chatStatusText: $('.status-text'), suggestionBtns: $$('.suggestion-btn'),
                slashCommandsMenu: $('#slashCommandsMenu'),
                // Preview/History Actions
                previewPdfBtn: $('#previewPdfBtn'), pdfStatus: $('#pdfStatus'), clearHistoryBtn: $('#clearHistoryBtn'),
                generateIepBtn: $('#generateIepBtn'),
                // Tabs
                chatTabs: $$('.tab-btn'),
            };

            // --- Initialization ---
            document.addEventListener('DOMContentLoaded', initializeApp);

            /**
             * Initializes the application: loads state, sets up listeners, updates UI.
             */
            function initializeApp() {
                console.log(`Initializing IEP Assistant Pro v${APP_VERSION}`);
                loadStateFromLocalStorage(); // Load first to apply settings
                initializeEventListeners();
                updateStudentDropdown();
                updateGroupDropdown();
                updateUIBasedOnSelection();
                setupAutoResizeTextarea();
                configureMarked();
                setupEnterKeyHandlers(); // Add Enter key support for forms
                console.log("Initialization Complete.");
                showToast("Welcome to IEP Assistant Pro!", 'info');
                 // Check for API keys and show warning if missing
                if (API_CONFIG.gemini.apiKey === "YOUR_GEMINI_API_KEY") { // Basic check
                    showToast("Gemini API Key missing. Please add it in the script.", 'warning', 8000);
                }
                 // Add similar check for Hugging Face if needed
            }

            /**
             * Setup event listeners for Enter key on form elements
             */
            function setupEnterKeyHandlers() {
                // Add enter key handlers to all input fields (except textareas and explicitly excluded ones)
                const inputFields = document.querySelectorAll('input:not([type="submit"]):not([data-no-enter-submit])');
                inputFields.forEach(input => {
                    input.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            // Find the next focusable element
                            const formElements = Array.from(document.querySelectorAll('input, select, textarea, button:not([disabled])'));
                            const currentIndex = formElements.indexOf(this);
                            const nextElement = formElements[currentIndex + 1];
                            
                            // If next element is a button, click it
                            if (nextElement && nextElement.tagName === 'BUTTON') {
                                nextElement.click();
                            } 
                            // If next element is an input, focus it
                            else if (nextElement) {
                                nextElement.focus();
                            }
                            // If this is the last element in a form, submit the form
                            else if (this.closest('form')) {
                                const form = this.closest('form');
                                const submitBtn = form.querySelector('button[type="submit"]');
                                if (submitBtn) {
                                    submitBtn.click();
                                } else {
                                    form.dispatchEvent(new Event('submit', { cancelable: true }));
                                }
                            }
                        }
                    });
                });
                
                // Add enter key handlers to select elements
                document.querySelectorAll('select:not([multiple]):not([data-no-enter-submit])').forEach(select => {
                    select.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const form = this.closest('form');
                            if (form) {
                                const submitBtn = form.querySelector('button[type="submit"]');
                                if (submitBtn) {
                                    submitBtn.click();
                                } else {
                                    form.dispatchEvent(new Event('submit', { cancelable: true }));
                                }
                            }
                        }
                    });
                });
            }

            /**
             * Sets up Marked.js configuration.
             */
            function configureMarked() {
                try {
                    marked.setOptions({
                        breaks: true, // Convert GFM line breaks to <br>
                        gfm: true,    // Enable GitHub Flavored Markdown
                        sanitize: false, // IMPORTANT: Rely on framework/manual sanitation if needed. For this app, assume AI output is mostly safe text/markdown.
                        mangle: false, // Don't obscure email addresses
                        headerIds: false // Don't add IDs to headers
                    });
                } catch (error) {
                    console.error("Error configuring Marked:", error);
                    showToast("Markdown parser setup failed.", 'error');
                }
            }

            // --- Event Listeners Setup ---
            function initializeEventListeners() {
                // Use a helper to add listeners and catch errors
                const addListener = (element, event, handler) => {
                    if (element) {
                        element.addEventListener(event, (e) => {
                            try { handler.call(element, e); } catch (error) { console.error(`Error in ${event} handler for ${element.id || element.tagName}:`, error); showToast(`UI Error: ${error.message}`, 'error'); }
                        });
                    } else { console.warn(`Element not found for listener: ${event}`); }
                };

                // Add event listener for the Generate IEP button
                addListener(elements.generateIepBtn, 'click', handleGenerateIEP);
                
                addListener(elements.toggleStudentFormBtn, 'click', () => toggleStudentForm());
                addListener(elements.cancelStudentFormBtn, 'click', () => toggleStudentForm(false));
                addListener(elements.studentForm, 'submit', handleAddOrUpdateStudent);
                addListener(elements.studentDropdown, 'change', handleStudentSelectionChange);
                addListener(elements.singleStudentDropdown, 'change', handleSingleStudentSelection);
                addListener(elements.refreshDataBtn, 'click', handleRefreshData);
                addListener(elements.groupDropdown, 'change', handleGroupSelectionChange);
                addListener(elements.studentSearch, 'input', debounce(handleStudentSearch, DEBOUNCE_DELAY)); // Debounced search
                addListener(elements.selectAllBtn, 'click', handleSelectAll);
                addListener(elements.deselectAllBtn, 'click', handleDeselectAll);
                addListener(elements.chatForm, 'submit', handleChatSubmit);
                addListener(elements.userMessageInput, 'keydown', handleChatInputKeydown);
                addListener(elements.userMessageInput, 'input', handleChatInputChange);
                addListener(elements.geminiBtn, 'click', () => switchApiModel('gemini'));
                addListener(elements.huggingfaceBtn, 'click', () => switchApiModel('huggingface'));
                addListener(elements.previewPdfBtn, 'click', exportToPDF);
                addListener(elements.createGroupBtn, 'click', handleCreateGroup);
                addListener(elements.bulkEditBtn, 'click', handleBulkEdit);
                addListener(elements.bulkGoalBtn, 'click', handleBulkGoal);
                addListener(elements.deleteGroupBtn, 'click', handleDeleteGroup);
                addListener(elements.clearHistoryBtn, 'click', handleClearHistory);
                addListener(elements.settingsBtn, 'click', openSettingsModal);

                elements.chatTabs?.forEach(tab => addListener(tab, 'click', () => switchTab(tab.dataset.tab)));
                elements.standardItems?.forEach(item => {
                    addListener(item, 'click', handleStandardSelection);
                    addListener(item, 'keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleStandardSelection.call(item, e); }); // Pass event
                });
                elements.suggestionBtns?.forEach(btn => addListener(btn, 'click', handleSuggestionClick));

                // Event delegation for dynamic content
                addListener(elements.iepPreviewContent, 'click', handlePreviewPanelClick);
                addListener(elements.chatMessages, 'click', handleChatMessageClick);
                addListener(elements.historyContent, 'click', handleChatMessageClick); // Enable copy from history too

                // Click outside slashCommandsMenu to close it
                document.addEventListener('click', (e) => {
                    if (elements.slashCommandsMenu && !elements.slashCommandsMenu.contains(e.target) && 
                        e.target !== elements.userMessageInput) {
                        hideSlashCommandsMenu();
                    }
                });

                console.log("Event listeners initialized.");
            }

            // --- State Management & Persistence ---

            // Memory storage fallback when localStorage isn't available
            const memoryStorage = {
                data: {},
                getItem(key) {
                    return this.data[key] || null;
                },
                setItem(key, value) {
                    this.data[key] = value;
                },
                removeItem(key) {
                    delete this.data[key];
                }
            };

            // Test if localStorage is available
            function isLocalStorageAvailable() {
                try {
                    const test = 'test';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            // Get the appropriate storage mechanism
            const storage = isLocalStorageAvailable() ? localStorage : memoryStorage;

            /**
             * Saves the current application state to storage.
             */
            function saveStateToLocalStorage() {
                try {
                    const stateToSave = {
                        students: appState.students,
                        studentGroups: appState.studentGroups,
                        settings: appState.settings,
                        activeModel: API_CONFIG.activeModel,
                        appVersion: APP_VERSION // Include version
                    };
                    storage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                    // console.debug("State saved."); // Less verbose logging
                } catch (error) {
                    console.error("Failed to save state:", error);
                    showToast("Error saving app state.", 'error');
                }
            }

            /**
             * Loads application state from storage, performs basic migration/validation.
             */
            function loadStateFromLocalStorage() {
                try {
                    const savedState = storage.getItem(STORAGE_KEY);
                    if (savedState) {
                        const parsedState = JSON.parse(savedState);

                        // Version Check (simple example - might need more complex logic for major version changes)
                        const loadedMajorVersion = parsedState.appVersion?.split('.')[0];
                        const currentMajorVersion = APP_VERSION.split('.')[0];
                        if (loadedMajorVersion !== currentMajorVersion) {
                            console.warn(`Loaded state version (${parsedState.appVersion}) major version differs from app version (${APP_VERSION}). Data might be incompatible. Attempting to load anyway.`);
                            showToast(`Loaded data from a potentially incompatible version (v${parsedState.appVersion}). Backup recommended.`, 'warning', 6000);
                        } else if (parsedState.appVersion !== APP_VERSION) {
                             console.log(`Loaded state version (${parsedState.appVersion}) differs from app version (${APP_VERSION}). Minor update.`);
                             // Potentially add minor migration logic here if needed
                        }


                        // Load and validate data structures
                        appState.students = (parsedState.students || []).map(s => ({
                            id: s.id || generateId('student'),
                            name: s.name || 'Unnamed Student',
                            grade: s.grade || '',
                            disabilityCategory: s.disabilityCategory || '',
                            currentPerformance: s.currentPerformance || '',
                            specialAccommodations: s.specialAccommodations || '',
                            servicesSupports: s.servicesSupports || '', // Added field default
                            iepGoals: (s.iepGoals || []).map(g => ({
                                id: g.id || generateId('goal'),
                                text: g.text || '',
                                standard: g.standard || '',
                                date: g.date || new Date().toLocaleDateString(),
                                progressNotes: (g.progressNotes || []).map(n => ({
                                    note: n.note || '',
                                    date: n.date || new Date().toISOString()
                                }))
                            })),
                            chatHistory: s.chatHistory || []
                        }));

                        appState.studentGroups = (parsedState.studentGroups || []).map(g => ({
                            id: g.id || generateId('group'),
                            name: g.name || 'Unnamed Group',
                            studentIndexes: g.studentIndexes || [],
                            chatHistory: g.chatHistory || []
                        }));

                        // Load settings, providing defaults
                        appState.settings = {
                            defaultModel: 'gemini', // Sensible default
                            darkMode: 'system', // Sensible default
                            ...(parsedState.settings || {}) // Overwrite with saved settings
                        };
                        API_CONFIG.activeModel = parsedState.activeModel || appState.settings.defaultModel;

                        applySettings(); // Apply loaded theme etc.
                        switchApiModel(API_CONFIG.activeModel, false); // Update UI buttons without message
                        console.log("State loaded successfully.");
                    } else {
                        console.log("No saved state found.");
                        // Apply default settings on first load
                        applySettings();
                        switchApiModel(API_CONFIG.activeModel, false);
                    }
                } catch (error) {
                    console.error("Failed to load or parse state:", error);
                    showToast("Error loading saved data. Resetting.", 'error');
                    storage.removeItem(STORAGE_KEY); // Clear corrupted state
                    // Optionally reload or reset appState to defaults
                }
            }

            /**
             * Applies settings from appState, e.g., dark mode.
             */
            function applySettings() {
                try {
                    // Dark Mode
                    if (appState.settings.darkMode === 'dark') {
                        document.documentElement.classList.add('dark');
                        localStorage.theme = 'dark';
                    } else if (appState.settings.darkMode === 'light') {
                        document.documentElement.classList.remove('dark');
                        localStorage.theme = 'light';
                    } else { // system
                        localStorage.removeItem('theme');
                        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                        document.documentElement.classList.toggle('dark', systemPrefersDark);

                        // Listen for system changes (optional but good UX)
                        // Ensure listener is only added once or managed properly if settings change often
                        window.matchMedia('(prefers-color-scheme: dark)').removeEventListener('change', handleSystemThemeChange); // Remove previous listener if exists
                        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', handleSystemThemeChange);
                    }
                    // Apply other settings if added
                } catch (error) {
                    console.error("Error applying settings:", error);
                }
            }

            /** Handles system dark mode preference changes. */
            function handleSystemThemeChange(event) {
                if (appState.settings.darkMode === 'system') {
                    document.documentElement.classList.toggle('dark', event.matches);
                }
            }


            // --- Core Functionality Handlers ---

            /**
             * Handles adding or updating a student record via the form.
             * @param {Event} e - The form submission event.
             */
            function handleAddOrUpdateStudent(e) {
                e.preventDefault();
                const form = e.target;
                const formData = new FormData(form);
                const name = formData.get('studentName').trim();
                const grade = formData.get('studentGrade');
                const disability = formData.get('disabilityCategory');

                // Enhanced Validation
                if (!name || name.length < 2 || !form.checkValidity()) {
                    showToast("Please fill all required fields correctly.", 'warning');
                    form.reportValidity(); // Show native browser validation messages
                    return;
                }

                const studentData = {
                    name: name, grade: grade, disabilityCategory: disability,
                    currentPerformance: formData.get('currentPerformance').trim(),
                    specialAccommodations: formData.get('specialAccommodations').trim(),
                    servicesSupports: formData.get('servicesSupports').trim(),
                };

                const existingIndex = appState.students.findIndex(s => s.name.toLowerCase() === name.toLowerCase());
                let targetIndex, message;

                if (existingIndex >= 0) { // Update
                    const existingStudent = appState.students[existingIndex];
                    // Preserve ID, goals, history when updating
                    appState.students[existingIndex] = {
                        ...existingStudent, // Keep existing ID, goals, history
                        ...studentData // Overwrite editable fields
                    };
                    targetIndex = existingIndex;
                    message = `Student "${studentData.name}" updated.`;
                } else { // Add
                    const newStudent = { ...studentData, id: generateId('student'), iepGoals: [], chatHistory: [] };
                    appState.students.push(newStudent);
                    targetIndex = appState.students.length - 1;
                    message = `Student "${studentData.name}" added.`;
                }

                // Select the student, update UI
                appState.selectedStudentIndexes = [targetIndex];
                appState.activeContext = 'student';
                appState.currentChatTarget = appState.students[targetIndex];
                if (elements.groupDropdown) elements.groupDropdown.value = "";

                saveStateToLocalStorage();
                updateStudentDropdown();
                updateUIBasedOnSelection();
                clearStudentForm();
                toggleStudentForm(false);
                showToast(message, 'success');
            }

            /**
             * Handles changes in the student multi-select dropdown.
             */
            function handleStudentSelectionChange() {
                appState.selectedStudentIndexes = Array.from(elements.studentDropdown.selectedOptions)
                    .map(opt => parseInt(opt.value, 10))
                    .filter(index => !isNaN(index) && index >= 0 && index < appState.students.length); // Add validation

                const count = appState.selectedStudentIndexes.length;

                if (elements.groupDropdown) elements.groupDropdown.value = ""; // Clear group if students selected manually
                appState.selectedGroupIndex = null;

                if (count === 1) {
                    appState.activeContext = 'student';
                    appState.currentChatTarget = appState.students[appState.selectedStudentIndexes[0]];
                } else if (count > 1) {
                    appState.activeContext = 'group';
                    appState.currentChatTarget = createAdHocGroupContext(appState.selectedStudentIndexes);
                } else {
                    appState.activeContext = 'none';
                    appState.currentChatTarget = null;
                }
                updateUIBasedOnSelection();
            }

            /**
             * Handles changes in the saved group dropdown.
             */
            function handleGroupSelectionChange() {
                const selectedIndex = parseInt(elements.groupDropdown.value, 10);
                if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < appState.studentGroups.length) { // Validate index
                    appState.selectedGroupIndex = selectedIndex;
                    appState.activeContext = 'group';
                    appState.currentChatTarget = appState.studentGroups[selectedIndex];
                    appState.selectedStudentIndexes = appState.currentChatTarget.studentIndexes || [];
                    // Update student dropdown to reflect group members
                    Array.from(elements.studentDropdown.options).forEach((opt) => {
                        opt.selected = appState.selectedStudentIndexes.includes(parseInt(opt.value, 10));
                    });
                } else { // "-- Select Group --" chosen or invalid index
                    appState.selectedGroupIndex = null;
                    if (elements.groupDropdown) elements.groupDropdown.value = ""; // Ensure dropdown reflects "-- Select Group --"
                    handleStudentSelectionChange(); // Revert context based on student selection
                    return;
                }
                updateUIBasedOnSelection();
            }

            /**
             * Filters the student dropdown based on search input.
             */
            function handleStudentSearch() {
                const searchTerm = elements.studentSearch.value.toLowerCase();
                Array.from(elements.studentDropdown.options).forEach(option => {
                    option.style.display = option.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
                });
            }

            /**
             * Handles clicks on standard items.
             * @this {HTMLElement} The clicked standard item element.
             */
            function handleStandardSelection() {
                if (this.classList.contains('opacity-50') || !this.hasAttribute('data-code')) return; // Ignore disabled or invalid

                if (appState.activeContext !== 'student') {
                    showToast("Select a single student first.", 'warning');
                    return;
                }
                const student = appState.currentChatTarget;
                if (!student) return;

                appState.selectedStandard = { code: this.dataset.code, title: this.querySelector('p:first-child')?.textContent || '', description: this.querySelector('p:last-child')?.textContent || '' };

                // Highlight selected standard briefly
                this.classList.add('bg-primary-light', 'dark:bg-primary-dark', 'ring-2', 'ring-primary-default');
                setTimeout(() => this.classList.remove('bg-primary-light', 'dark:bg-primary-dark', 'ring-2', 'ring-primary-default'), 1000);

                addMessage('user', `Generate goal for ${student.name} using standard: ${appState.selectedStandard.title}`);
                const prompt = `Create a SMART IEP goal for student ${student.name} (Grade ${getGradeName(student.grade)}, ${getDisabilityName(student.disabilityCategory)}) aligned with Indiana DOE standard: ${appState.selectedStandard.code}: ${appState.selectedStandard.description}.\nPresent Levels: ${student.currentPerformance || 'N/A'}\nAccommodations: ${student.specialAccommodations || 'N/A'}\nServices: ${student.servicesSupports || 'N/A'}\nFormat the output clearly with the heading "SMART Goal:" followed by the goal. Ensure the goal is measurable and time-bound.`;
                sendToChatbot(prompt, student);
            }

            /**
             * Analyzes user message for natural language command intent
             * @param {string} message - The user message
             * @returns {object|null} The detected command or null if no command found
             */
            function detectNaturalLanguageCommand(message) {
                message = message.toLowerCase().trim();
                
                // Skip if message starts with slash (explicit command)
                if (message.startsWith('/')) return null;
                
                // Check for each command's synonyms
                for (const cmd of SLASH_COMMANDS) {
                    // Check for command verb match
                    const commandMatch = cmd.synonyms.some(synonym => 
                        message.includes(synonym) || 
                        message.startsWith(synonym)
                    );
                    
                    if (commandMatch) {
                        // For each option, check if it appears in the message
                        for (const option of cmd.options) {
                            const optionSynonyms = cmd.optionSynonyms?.[option] || [];
                            
                            // Check if option or its synonyms appear in the message
                            if (message.includes(option) || optionSynonyms.some(syn => message.includes(syn))) {
                                // If both command and option are found, return the command
                                return {
                                    command: cmd.command,
                                    option: option,
                                    args: [option],
                                    execute: () => cmd.execute([option])
                                };
                            }
                        }
                        
                        // If we found a command but no specific option, just return the command
                        if (cmd.options.length === 0) {
                            return {
                                command: cmd.command,
                                execute: () => cmd.execute([])
                            };
                        }
                    }
                }
                
                // Special case for "generate complete IEP" pattern
                if (message.includes("generate") && 
                   (message.includes("complete iep") || 
                    message.includes("full iep") || 
                    message.includes("entire iep") || 
                    message.includes("comprehensive iep"))) {
                    return {
                        command: "/gen",
                        option: "complete",
                        args: ["complete"],
                        execute: () => handleGenerateIEP()
                    };
                }
                
                return null;
            }

            /**
             * Handles chat form submission.
             * @param {Event} e - The form submission event.
             */
            function handleChatSubmit(e) {
                e.preventDefault();
                const message = elements.userMessageInput.value.trim();
                if (!message) return;

                // Check if message is a slash command
                if (message.startsWith('/')) {
                    if (processChatCommand(message)) {
                        elements.userMessageInput.value = ''; adjustTextareaHeight(elements.userMessageInput); return;
                    }
                    // If command not recognized, fall through to send as message
                } else {
                    // Check for natural language commands
                    const nlCommand = detectNaturalLanguageCommand(message);
                    if (nlCommand) {
                        addMessage('user', message); // Show original message
                        try {
                            nlCommand.execute();
                            elements.userMessageInput.value = '';
                            adjustTextareaHeight(elements.userMessageInput);
                            hideSlashCommandsMenu();
                            return;
                        } catch (error) {
                            console.error("Error executing NL command:", error);
                            // Fall through to regular message if command execution fails
                        }
                    }
                }

                if (appState.activeContext === 'none') {
                    showToast("Select a student or group first.", 'warning'); return;
                }
                addMessage('user', message);
                sendToChatbot(message, appState.currentChatTarget);
                elements.userMessageInput.value = '';
                adjustTextareaHeight(elements.userMessageInput);
                hideSlashCommandsMenu();
            }

            /**
             * Handles clicks on quick suggestion buttons.
             * @param {Event} e - The button click event.
             */
            function handleSuggestionClick(e) {
                const suggestion = e.target.textContent;
                if (elements.userMessageInput) {
                    elements.userMessageInput.value = suggestion;
                    adjustTextareaHeight(elements.userMessageInput);
                    elements.userMessageInput.focus();
                }
            }

            /**
             * Handles creating a new saved group from selected students.
             */
            function handleCreateGroup() {
                if (appState.selectedStudentIndexes.length < 1) { // Changed to allow group of 1+
                    showToast("Select at least one student first.", 'warning'); return;
                }
                const groupName = prompt(`Enter name for the group (${appState.selectedStudentIndexes.length} student(s)):`);
                if (groupName && groupName.trim()) {
                    const newGroup = { id: generateId('group'), name: groupName.trim(), studentIndexes: [...appState.selectedStudentIndexes], chatHistory: [] };
                    appState.studentGroups.push(newGroup);
                    appState.selectedGroupIndex = appState.studentGroups.length - 1;
                    appState.activeContext = 'group';
                    appState.currentChatTarget = newGroup;

                    saveStateToLocalStorage();
                    updateGroupDropdown(); // Selects the new group
                    updateUIBasedOnSelection();
                    showToast(`Group "${newGroup.name}" created.`, 'success');
                    addMessage('assistant', `Created group "${newGroup.name}". You are now chatting with this group.`);
                }
            }

            /**
             * Handles deleting the currently selected saved group.
             */
            function handleDeleteGroup() {
                if (appState.selectedGroupIndex === null || appState.selectedGroupIndex < 0 || appState.selectedGroupIndex >= appState.studentGroups.length) {
                    showToast("Select a valid saved group to delete.", 'warning'); return;
                }
                const groupToDelete = appState.studentGroups[appState.selectedGroupIndex];
                if (confirm(`DELETE Group "${groupToDelete.name}"?\nThis cannot be undone.`)) {
                    const deletedGroupName = groupToDelete.name; // Store name before splicing
                    appState.studentGroups.splice(appState.selectedGroupIndex, 1);
                    appState.selectedGroupIndex = null;
                    if (elements.groupDropdown) elements.groupDropdown.value = "";

                    saveStateToLocalStorage();
                    updateGroupDropdown();
                    handleStudentSelectionChange(); // Revert context based on student selection

                    showToast(`Group "${deletedGroupName}" deleted.`, 'success');
                    addMessage('assistant', `Group "${deletedGroupName}" deleted.`);
                }
            }

            /**
             * Initiates the bulk edit process for selected students.
             */
            function handleBulkEdit() {
                if (appState.selectedStudentIndexes.length < 1) {
                    showToast("Select students to bulk edit.", 'warning'); return;
                }
                openBulkEditModal(appState.selectedStudentIndexes.map(i => appState.students[i]));
            }

            /**
             * Initiates AI suggestion for a group goal based on selection.
             */
            function handleBulkGoal() {
                if (appState.selectedStudentIndexes.length < 1) {
                    showToast("Select students to suggest a group goal.", 'warning'); return;
                }
                const selectedStudents = appState.selectedStudentIndexes.map(i => appState.students[i]);
                const studentSummaries = selectedStudents.map(s => `${s.name} (Gr ${getGradeName(s.grade)}, ${getDisabilityName(s.disabilityCategory)})`).join('; ');
                const commonNeeds = identifyCommonNeeds(selectedStudents); // Placeholder for potential future logic

                let prompt = `Generate a sample SMART IEP goal suitable for a group of students with potentially varying needs. The group includes: ${studentSummaries}.`;
                if (commonNeeds) prompt += `\nConsider common needs like: ${commonNeeds}.`;
                prompt += `\nThe goal should be adaptable. Focus on a common academic or functional area. Format the output clearly with the heading "Group Goal Idea:" followed by the goal and adaptation suggestions.`;

                addMessage('user', `Suggest group goal for ${selectedStudents.length} selected students.`);
                sendToChatbot(prompt, createAdHocGroupContext(appState.selectedStudentIndexes));
            }

            /**
             * Handles clearing chat history for the current context (student or saved group).
             */
            function handleClearHistory() {
                if (!appState.currentChatTarget || appState.activeContext === 'none' || appState.currentChatTarget.isAdHoc) {
                    showToast("Select a student or saved group first.", 'warning'); return;
                }
                const targetName = appState.currentChatTarget.name;
                if (confirm(`Clear chat history for "${targetName}"?\nThis cannot be undone.`)) {
                    appState.currentChatTarget.chatHistory = [];
                    saveStateToLocalStorage();
                    loadChatHistory(); // Refresh panel
                    showToast(`Chat history for "${targetName}" cleared.`, 'success');
                    addMessage('assistant', `Chat history for "${targetName}" cleared.`);
                }
            }

            /**
             * Handles clicks within the IEP preview panel (delegated).
             * @param {Event} e - The click event.
             */
            function handlePreviewPanelClick(e) {
                const goalElement = e.target.closest('.goal-item');
                if (!goalElement || appState.activeContext !== 'student') return;

                const goalId = goalElement.dataset.goalId;
                const student = appState.currentChatTarget;
                const goal = student?.iepGoals.find(g => g.id === goalId);
                if (!goal) return;

                const goalIndex = student.iepGoals.findIndex(g => g.id === goalId) + 1;

                if (e.target.closest('.delete-goal-btn')) {
                    if (confirm(`Delete Goal ${goalIndex}?`)) {
                        student.iepGoals = student.iepGoals.filter(g => g.id !== goalId);
                        saveStateToLocalStorage(); updatePreview(); showToast(`Goal ${goalIndex} deleted.`, 'success');
                    }
                } else if (e.target.closest('.add-note-btn')) {
                    openProgressNoteModal(student, goal);
                } else if (e.target.closest('.toggle-notes-btn')) {
                    const notesList = goalElement.querySelector('.progress-notes-list');
                    const icon = e.target.closest('.toggle-notes-btn').querySelector('svg');
                    notesList?.classList.toggle('hidden');
                    icon?.classList.toggle('rotate-180');
                    e.target.closest('.toggle-notes-btn').setAttribute('aria-expanded', !notesList?.classList.contains('hidden'));
                } else if (e.target.closest('.refine-goal-btn')) {
                    handleRefineGoal(student, goal);
                }
            }

            /**
             * Handles clicks within the chat message list (delegated for copy).
             * @param {Event} e - The click event.
             */
            function handleChatMessageClick(e) {
                const copyButton = e.target.closest('.copy-btn');
                if (copyButton) {
                    const messageBubble = copyButton.closest('.chat-bubble');
                    if (messageBubble) {
                         // Get text content, excluding the copy button itself if it got included
                         const textToCopy = Array.from(messageBubble.childNodes)
                            .filter(node => node.nodeType === Node.TEXT_NODE || (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('copy-btn')))
                            .map(node => node.textContent)
                            .join('');

                        navigator.clipboard.writeText(textToCopy.trim())
                            .then(() => {
                                copyButton.innerHTML = `<svg class="h-3 w-3 text-success-default"><use href="#icon-check"/></svg>`;
                                setTimeout(() => { copyButton.innerHTML = `<svg class="h-3 w-3 text-gray-600 dark:text-gray-400"><use href="#icon-copy"/></svg>`; }, 1500);
                            })
                            .catch(err => { console.error('Copy failed:', err); showToast('Failed to copy.', 'error'); });
                    }
                }
            }

            /**
             * Sends a selected goal back to the AI for refinement.
             * @param {object} student - The student object.
             * @param {object} goal - The goal object to refine.
             */
            function handleRefineGoal(student, goal) {
                if (!student || !goal) return;
                const goalIndex = student.iepGoals.findIndex(g => g.id === goal.id);
                if (goalIndex === -1) { showToast("Error finding goal to refine.", 'error'); return; }

                const prompt = `Refine the following SMART IEP goal for student ${student.name} (Grade ${getGradeName(student.grade)}, ${getDisabilityName(student.disabilityCategory)}). Make it clearer, more measurable, or suggest alternative phrasing if appropriate. Keep the core intent.\n\nOriginal Goal (Goal ${goalIndex + 1}):\n${goal.text}\n\nProvide the refined goal labeled "Refined Goal:".`;
                addMessage('user', `Refine Goal ${goalIndex + 1} for ${student.name}`);
                sendToChatbot(prompt, student);
                // Note: The response processing will need to handle "Refined Goal:" and potentially *replace* the existing goal.
            }


            // --- API Interaction ---

            /**
             * Sends a message to the currently configured AI model.
             * @param {string} message - The user's message/prompt.
             * @param {object} context - The current student or group object.
             */
            async function sendToChatbot(message, context) {
                if (!context) { showToast("Error: No context for chat.", 'error'); return; }

                // Add user message to history (if applicable)
                if (context.chatHistory && !context.isAdHoc) {
                    context.chatHistory.push({ role: 'user', content: message, timestamp: new Date().toISOString() });
                    saveStateToLocalStorage(); // Save immediately after adding user message
                }

                startThinkingIndicator();
                try {
                    const apiFunction = API_CONFIG.activeModel === "gemini" ? sendToGemini : sendToHuggingFace;
                    const responseContent = await apiFunction(message, context);
                    processModelResponse(responseContent, context);
                } catch (error) {
                    console.error(`API error (${API_CONFIG.activeModel}):`, error);
                    stopThinkingIndicator();
                    const errorMessage = `AI Error (${API_CONFIG.activeModel}): ${error.message}`;
                    showToast(errorMessage, 'error');
                    addMessage('assistant', `⚠️ ${errorMessage}`); // Also add error to chat for visibility
                     // Add error to history if context allows
                    if (context.chatHistory && !context.isAdHoc) {
                        context.chatHistory.push({ role: 'assistant', content: `Error: ${error.message}`, timestamp: new Date().toISOString() });
                        saveStateToLocalStorage();
                    }
                }
            }

            /**
             * Sends request to Google Gemini API.
             * @param {string} message - User message.
             * @param {object} context - Student or group context.
             * @returns {Promise<string>} The AI response text.
             */
            async function sendToGemini(message, context) {
                const { apiKey, endpoint, headers } = API_CONFIG.gemini;
                if (apiKey === "YOUR_GEMINI_API_KEY") throw new Error("Gemini API Key not configured."); // Fail fast
                const url = `${endpoint}?key=${apiKey}`;
                const systemPrompt = generateSystemPrompt(context);

                try {
                    const response = await fetch(url, {
                        method: "POST", headers: headers,
                        body: JSON.stringify({
                            contents: [{ role: "user", parts: [{ text: systemPrompt + "\n\nUser Query: " + message }] }],
                            generationConfig: { temperature: 0.6, topK: 40, topP: 0.95, maxOutputTokens: 2500 } // Slightly lower temp, more tokens
                        })
                    });
                    if (!response.ok) { throw await handleApiError(response, 'Gemini'); }
                    const data = await response.json();
                    if (data.candidates?.[0]?.content?.parts?.[0]?.text) return data.candidates[0].content.parts[0].text;
                    if (data.promptFeedback?.blockReason) throw new Error(`Blocked: ${data.promptFeedback.blockReason}`);
                    // Handle cases where the response might be empty or lack the expected structure
                    if (data.candidates?.[0]?.finishReason && data.candidates[0].finishReason !== 'STOP') {
                        throw new Error(`Generation stopped: ${data.candidates[0].finishReason}`);
                    }
                    throw new Error("Unexpected Gemini response format or empty content.");
                } catch (error) { console.error("Gemini Fetch Error:", error); throw error; }
            }

            /**
             * Sends request to Hugging Face Inference API.
             * @param {string} message - User message.
             * @param {object} context - Student or group context.
             * @returns {Promise<string>} The AI response text.
             */
            async function sendToHuggingFace(message, context) {
                const { endpoint, headers } = API_CONFIG.huggingface;
                if (!headers.Authorization || headers.Authorization === "Bearer YOUR_HF_TOKEN") throw new Error("Hugging Face API Key not configured."); // Fail fast
                const systemPrompt = generateSystemPrompt(context);
                const formattedPrompt = `<s>[INST] ${systemPrompt}\n\nUser Query: ${message} [/INST]</s>`;

                try {
                    const response = await fetch(endpoint, {
                        method: "POST", headers: headers,
                        body: JSON.stringify({
                            inputs: formattedPrompt,
                            parameters: { max_new_tokens: 2500, temperature: 0.7, top_p: 0.95, do_sample: true, return_full_text: false }
                        })
                    });
                    if (!response.ok) { throw await handleApiError(response, 'HuggingFace'); }
                    const data = await response.json();
                    if (Array.isArray(data) && data[0]?.generated_text) return data[0].generated_text.trim();
                    // Handle potential error structures from HF
                     if (data.error) throw new Error(`HuggingFace Error: ${data.error}`);
                    throw new Error("Unexpected HuggingFace response format.");
                } catch (error) { console.error("HF Fetch Error:", error); throw error; }
            }

            /**
             * Handles API error responses.
             * @param {Response} response - The fetch Response object.
             * @param {string} apiName - Name of the API for logging.
             * @returns {Promise<Error>} A rejected Promise with an Error object.
             */
            async function handleApiError(response, apiName) {
                let errorMsg = `HTTP error ${response.status} (${response.statusText})`;
                try {
                    const errorData = await response.json();
                    console.error(`${apiName} API Error Response:`, errorData);
                    errorMsg = errorData.error?.message || JSON.stringify(errorData.error) || errorMsg;
                } catch {
                    try { errorMsg = await response.text() || errorMsg; } catch {} // Get text if JSON fails
                }
                return new Error(errorMsg);
            }


            /**
             * Processes the response from the AI model.
             * @param {string} content - The raw response content from the AI.
             * @param {object} context - The student or group context for the request.
             */
            function processModelResponse(content, context) {
                stopThinkingIndicator();
                addMessage('assistant', content); // Display raw response

                if (context?.chatHistory && !context.isAdHoc) {
                    context.chatHistory.push({ role: 'assistant', content: content, timestamp: new Date().toISOString() });
                    saveStateToLocalStorage(); // Save after adding assistant message
                }

                // --- Section Generation Handling ---
                if (appState.activeContext === 'student' && context && !context.isAdHoc) {
                    let sectionUpdated = false;
                    if (content.match(/^(PLAAFP|Present Levels):/im)) {
                         const sectionContent = content.replace(/^(PLAAFP|Present Levels):/im, '').trim();
                         context.currentPerformance = sectionContent;
                         showToast('PLAAFP updated from AI response.', 'success');
                         sectionUpdated = true;
                    } else if (content.match(/^(Accommodations|Modifications|Supports):/im)) {
                        const sectionContent = content.replace(/^(Accommodations|Modifications|Supports):/im, '').trim();
                         context.specialAccommodations = sectionContent; // Or append? Let's replace for now.
                         showToast('Accommodations updated from AI response.', 'success');
                         sectionUpdated = true;
                    } else if (content.match(/^(Services):/im)) {
                         const sectionContent = content.replace(/^(Services):/im, '').trim();
                         context.servicesSupports = sectionContent;
                         showToast('Services/Supports updated from AI response.', 'success');
                         sectionUpdated = true;
                    }
                    if (sectionUpdated) {
                        saveStateToLocalStorage();
                        updatePreview(); // Update preview only if a section was modified
                    }
                }


                // --- Goal Extraction / Refinement Handling ---
                if (appState.activeContext === 'student' && context && !context.isAdHoc) {
                    const student = context;
                    const refinedGoalMatch = content.match(/Refined Goal:([\s\S]*)/i);
                    const newGoalMatch = extractGoalFromResponse(content); // Check for standard "SMART Goal:" etc.

                    if (refinedGoalMatch && refinedGoalMatch[1]) {
                        // Attempt to find the goal that was *likely* just refined (e.g., the last one mentioned in user history)
                        const userMessages = student.chatHistory.filter(m => m.role === 'user').slice(-2); // Look at last couple user messages
                        const refineRequest = userMessages.find(m => m.content.toLowerCase().includes('refine goal'));
                        if (refineRequest) {
                            const goalIndexMatch = refineRequest.content.match(/refine goal (\d+)/i);
                            if (goalIndexMatch && goalIndexMatch[1]) {
                                const goalIndex = parseInt(goalIndexMatch[1], 10) - 1;
                                if (goalIndex >= 0 && goalIndex < student.iepGoals.length) {
                                    const oldGoalText = student.iepGoals[goalIndex].text;
                                    student.iepGoals[goalIndex].text = refinedGoalMatch[1].trim();
                                    student.iepGoals[goalIndex].date = new Date().toLocaleDateString(); // Update date on refinement
                                    saveStateToLocalStorage(); updatePreview();
                                    showToast(`Goal ${goalIndex + 1} refined.`, 'success');
                                    console.log(`Refined Goal ${goalIndex + 1}. Old: "${oldGoalText.substring(0,30)}...", New: "${student.iepGoals[goalIndex].text.substring(0,30)}..."`);
                                } else { console.warn("Could not find goal index mentioned in refine request."); showToast("Goal refinement failed: Index mismatch.", 'warning'); }
                            } else { console.warn("Could not extract goal index from refine request."); showToast("Goal refinement failed: Could not identify target goal.", 'warning'); }
                        } else { console.warn("Could not find recent refine request in history."); showToast("Goal refinement failed: Could not link to request.", 'warning'); }

                    } else if (newGoalMatch) { // Handle standard new goal addition
                        const goalText = newGoalMatch;
                        const newGoal = {
                            id: generateId('goal'), text: goalText,
                            standard: appState.selectedStandard?.code || "",
                            date: new Date().toLocaleDateString(), progressNotes: []
                        };
                        student.iepGoals.push(newGoal);
                        saveStateToLocalStorage();
                        setTimeout(() => {
                            addMessage('assistant', `✅ Goal added to ${student.name}'s IEP.`);
                            updatePreview();
                        }, 300); // Slight delay for visual separation
                    }
                }
                appState.selectedStandard = null; // Clear standard selection after processing any response
            }

            /**
             * Extracts a potential goal text from the AI response.
             * Looks for common goal indicators.
             * @param {string} content - The AI response content.
             * @returns {string | null} The extracted goal text or null.
             */
            function extractGoalFromResponse(content) {
                // Look for "SMART Goal:", "Annual Goal:", etc., potentially with variations in casing and surrounding whitespace/formatting.
                const goalMatch = content.match(/^(?:SMART Goal|Annual Goal|Measurable Goal)\s*:\s*([\s\S]*)/im);
                if (goalMatch && goalMatch[1]) {
                    return goalMatch[1].trim();
                }
                // Add more patterns here if needed
                return null;
            }

            /**
             * Process the AI response from the IEP generation to extract different sections.
             * @param {string} response - The full AI response text
             * @param {object} student - The student object to update
             */
            function processIEPResponse(response, student) {
                // Extract PLAAFP section
                const plaafpMatch = response.match(/(?:Present Levels|PLAAFP)(?:\s*\(PLAAFP\))?[:\\s]+([\\s\\S]+?)(?=(?:Accommodations|Goals|Services|$))/i);
                if (plaafpMatch && plaafpMatch[1]) {
                    student.currentPerformance = plaafpMatch[1].trim();
                }
                
                // Extract Accommodations section
                const accomMatch = response.match(/Accommodations(?:\s*(?:and|&)\s*Modifications)?[:\\s]+([\\s\\S]+?)(?=(?:Services|Goals|Present|$))/i);
                if (accomMatch && accomMatch[1]) {
                    student.specialAccommodations = accomMatch[1].trim();
                }
                
                // Extract Services section
                const servicesMatch = response.match(/Services(?:\s*(?:and|&)\s*Supports)?[:\\s]+([\\s\\S]+?)(?=(?:Goals|Accommodations|Present|$))/i);
                if (servicesMatch && servicesMatch[1]) {
                    student.servicesSupports = servicesMatch[1].trim();
                }
                
                // Extract SMART Goals
                const goalMatches = response.matchAll(/SMART Goal(?:\s*\d+)?[:\\s]+([^]*?)(?=(?:SMART Goal|$))/gi);
                const extractedGoals = Array.from(goalMatches, m => m[1].trim()).filter(Boolean);
                
                if (extractedGoals.length > 0) {
                    // Option 2: Add new goals while keeping existing ones
                    extractedGoals.forEach(text => {
                        // Check if this goal is substantially similar to any existing goal
                        const isDuplicate = student.iepGoals.some(goal => 
                            goal.text.toLowerCase().includes(text.substring(0, 40).toLowerCase()) || 
                            text.toLowerCase().includes(goal.text.substring(0, 40).toLowerCase())
                        );
                        
                        if (!isDuplicate) {
                            student.iepGoals.push({
                                id: generateId('goal'),
                                text: text,
                                date: new Date().toLocaleDateString(),
                                progressNotes: []
                            });
                        }
                    });
                }
                
                // Save changes and update UI
                saveStateToLocalStorage();
                updatePreview();
                
                // Add to chat history
                addMessage('assistant', `✅ Complete IEP generated for ${student.name}. All sections have been updated.`);
            }
            
            /**
             * Handles the "Generate IEP" button click to trigger AI-driven comprehensive IEP generation.
             * Also used for the "/gen complete" command.
             */
            function handleGenerateIEP() {
                if (appState.activeContext !== 'student' || !appState.currentChatTarget) {
                    showToast("Select a single student to generate an IEP.", 'warning');
                    return;
                }
                
                const student = appState.currentChatTarget;
                const btn = $('#generateIepBtn');
                
                if (btn) {
                    // Show loading state
                    const originalBtnText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = `<svg class="animate-spin-fast h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating AI IEP...`;
                    
                    showToast("Starting comprehensive IEP generation...", 'info');
                    
                    // Build a comprehensive prompt for the AI
                    const prompt = `Generate a comprehensive IEP for ${student.name}, a ${getGradeName(student.grade)} student with ${getDisabilityName(student.disabilityCategory)}. 
                    \nBased on available information, generate ALL of the following IEP components in a structured, well-organized format:

1. Present Levels of Academic Achievement and Functional Performance (PLAAFP)
${student.currentPerformance ? `Use and expand upon this existing PLAAFP: "${student.currentPerformance}"` : `Create a detailed PLAAFP addressing both academic and functional performance areas relevant to ${getDisabilityName(student.disabilityCategory)}.`}

2. Accommodations and Modifications
${student.specialAccommodations ? `Use and expand upon these existing accommodations: "${student.specialAccommodations}"` : `Recommend appropriate accommodations and modifications for a ${getGradeName(student.grade)} student with ${getDisabilityName(student.disabilityCategory)}.`}

3. Services and Supports
${student.servicesSupports ? `Use and expand upon these existing services: "${student.servicesSupports}"` : `Recommend appropriate related services, frequency, and duration for a student with ${getDisabilityName(student.disabilityCategory)}.`}

4. Goals and Objectives (include at least 3 SMART goals)
${student.iepGoals && student.iepGoals.length > 0 
    ? `Include and refine these existing goals: ${student.iepGoals.map((g, i) => `Goal ${i+1}: ${g.text}`).join('\n')}` 
    : `Create at least 3 SMART goals addressing different areas of need for a ${getGradeName(student.grade)} student with ${getDisabilityName(student.disabilityCategory)}.`}

\nFormat each section with clear headings. Present SMART goals in a numbered format preceded by "SMART Goal:". Be specific, educational, and professional in your language.

\nAlso consider any relevant information from the chat history with this student when generating content.`;
                    
                    // Process the request to the AI
                    setTimeout(async () => {
                        try {
                            // Use the appropriate API model
                            const apiFunction = API_CONFIG.activeModel === "gemini" ? sendToGemini : sendToHuggingFace;
                            const response = await apiFunction(prompt, student);
                            
                            // Process the response to extract sections and update student record
                            processIEPResponse(response, student);
                            
                            // Switch to preview tab to show the results
                            switchTab('preview');
                            
                            showToast(`IEP generated for ${student.name}!`, 'success');
                        } catch (error) {
                            console.error("IEP Generation Error:", error);
                            showToast(`Error generating IEP: ${error.message}`, 'error');
                        } finally {
                            // Restore button state
                            if (btn) {
                                btn.disabled = false;
                                btn.innerHTML = originalBtnText;
                            }
                        }
                    }, 500); // Short delay for UI feedback
                }
            }

            // --- UI Update Functions ---

            /**
             * Updates the entire UI based on the current application state (context, selection).
             */
            function updateUIBasedOnSelection() {
                const { activeContext: context, currentChatTarget: target, selectedStudentIndexes, selectedGroupIndex } = appState;
                const selectionCount = selectedStudentIndexes.length;

                // Chat Header
                if (elements.chatHeader) {
                    elements.chatHeader.textContent = context === 'student' ? `Chatting with: ${target.name}`
                                                : context === 'group' ? `Chatting with Group: ${target.name}`
                                                : "Chat Assistant";
                }

                // Selection Status
                if (elements.selectionStatus) {
                    elements.selectionStatus.textContent = context === 'student' ? `1 Student Selected`
                                                        : context === 'group' ? `${selectionCount} Students Selected` + (target?.isAdHoc ? '' : ` (Group: ${target?.name || '...'})`)
                                                        : 'No Selection';
                }

                // Group Actions & Buttons
                const enableGroupActions = selectionCount > 0;
                if (elements.groupActionsContainer) elements.groupActionsContainer.classList.toggle('opacity-50', !enableGroupActions); // Visually indicate disabled state
                if (elements.createGroupBtn) elements.createGroupBtn.disabled = selectionCount < 1; // Allow group of 1+
                if (elements.bulkEditBtn) elements.bulkEditBtn.disabled = selectionCount < 1;
                if (elements.bulkGoalBtn) elements.bulkGoalBtn.disabled = selectionCount < 1;
                if (elements.deleteGroupBtn) elements.deleteGroupBtn.disabled = context !== 'group' || target?.isAdHoc;

                // Standard Selection Area
                const standardsEnabled = context === 'student';
                if (elements.standardSelectionInfo) elements.standardSelectionInfo.classList.toggle('hidden', !standardsEnabled);
                if (standardsEnabled && elements.standardContext && target) elements.standardContext.textContent = target.name;
                elements.standardItems.forEach(item => {
                    item.classList.toggle('opacity-50', !standardsEnabled);
                    item.classList.toggle('cursor-not-allowed', !standardsEnabled);
                    item.setAttribute('aria-disabled', (!standardsEnabled).toString());
                    item.setAttribute('tabindex', standardsEnabled ? '0' : '-1');
                });

                // Enable Generate IEP button only when a student is selected
                if (elements.generateIepBtn) {
                    elements.generateIepBtn.disabled = context !== 'student';
                }

                // Update Panels & Action Buttons
                updatePreview();
                loadChatHistory();
                if (elements.previewPdfBtn) elements.previewPdfBtn.disabled = context !== 'student';
                if (elements.clearHistoryBtn) elements.clearHistoryBtn.disabled = context === 'none' || target?.isAdHoc;

                console.debug(`UI Updated. Context: ${context}, Target: ${target?.name || 'None'}, Selection Count: ${selectionCount}`);
            }

            /**
             * Updates the student dropdown list based on appState.students.
             */
            function updateStudentDropdown() {
                const currentSelectionIds = appState.selectedStudentIndexes.map(i => appState.students[i]?.id).filter(id => id);
                if (!elements.studentDropdown) return;
                elements.studentDropdown.innerHTML = ''; // Clear

                // Also update the single student dropdown
                if (elements.singleStudentDropdown) {
                    elements.singleStudentDropdown.innerHTML = '<option value="">-- Select a Student --</option>';
                }

                if (appState.students.length === 0) {
                    elements.studentDropdown.innerHTML = '<option disabled>No students added yet</option>';
                } else {
                    const sortedStudents = [...appState.students].sort((a, b) => a.name.localeCompare(b.name));
                    sortedStudents.forEach(student => {
                        const originalIndex = appState.students.findIndex(s => s.id === student.id);
                        
                        // Multi-select dropdown
                        const option = document.createElement('option');
                        option.value = originalIndex;
                        option.textContent = `${student.name} (Gr ${getGradeName(student.grade)})`;
                        option.selected = currentSelectionIds.includes(student.id);
                        elements.studentDropdown.appendChild(option);
                        
                        // Single student dropdown
                        if (elements.singleStudentDropdown) {
                            const singleOption = document.createElement('option');
                            singleOption.value = originalIndex;
                            singleOption.textContent = `${student.name} (Gr ${getGradeName(student.grade)})`;
                            // If there's a current chat target that's a student, select it
                            if (appState.activeContext === 'student' && appState.currentChatTarget && 
                                appState.currentChatTarget.id === student.id) {
                                singleOption.selected = true;
                            }
                            elements.singleStudentDropdown.appendChild(singleOption);
                        }
                    });
                }
                handleStudentSearch(); // Apply filter after updating
            }

            /**
             * Updates the saved group dropdown list.
             */
            function updateGroupDropdown() {
                 if (!elements.groupDropdown) return;
                elements.groupDropdown.innerHTML = '<option value="">-- Select a Group --</option>';
                appState.studentGroups.sort((a,b) => a.name.localeCompare(b.name)).forEach((group, index) => {
                    // Find the original index before sorting if needed, but using array index after sort is fine here
                    const originalIndex = appState.studentGroups.findIndex(g => g.id === group.id);
                    const option = document.createElement('option');
                    option.value = originalIndex; // Use original index for consistency with appState
                    option.textContent = `${group.name} (${group.studentIndexes?.length || 0})`;
                    option.selected = appState.selectedGroupIndex === originalIndex;
                    elements.groupDropdown.appendChild(option);
                });
            }

            /**
             * Updates the IEP Preview panel based on the current context.
             */
            function updatePreview() {
                if (!elements.previewDetails || !elements.previewStatus) return;
                elements.previewDetails.innerHTML = ''; // Clear previous details
                const { activeContext: context, currentChatTarget: target } = appState;

                if (context === 'student' && target) {
                    elements.previewStatus.textContent = `Preview for ${target.name}`;
                    elements.previewDetails.innerHTML = generateStudentPreviewHTML(target);
                    // Apply specific styling to headings after HTML is inserted
                    elements.previewDetails.querySelectorAll('h3').forEach(h3 => h3.classList.add('preview-heading'));
                } else {
                    elements.previewStatus.textContent = context === 'group' ? `Preview N/A for Groups` : `Select a Student`;
                    elements.previewDetails.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 italic mt-6">Select a single student to view their detailed IEP preview.</p>`;
                }
            }

             /**
             * Generates the HTML content for the student preview panel.
             * @param {object} student - The student object.
             * @returns {string} The HTML string for the preview details.
             */
             function generateStudentPreviewHTML(student) {
                 const renderNotes = (notes) => {
                     if (!notes || notes.length === 0) return '<p class="text-xs italic text-gray-500 dark:text-gray-400 mt-1 ml-4">No progress notes.</p>';
                     // Sort notes newest first for display
                     return [...notes].sort((a, b) => new Date(b.date) - new Date(a.date)).map(note => `
                         <li class="ml-4 text-xs border-l border-base-300 dark:border-dark-300 pl-2 py-1">
                             <span class="font-medium">${new Date(note.date).toLocaleDateString()}:</span> ${escapeHtml(note.note)}
                         </li>`).join('');
                 };

                 return `
                    <div class="space-y-6">
                        <!-- Student Info -->
                        <div><h3>Student Information</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-1 text-sm"><div><span class="font-medium">Name:</span> ${escapeHtml(student.name)}</div><div><span class="font-medium">Grade:</span> ${getGradeName(student.grade)}</div><div><span class="font-medium">Disability:</span> ${getDisabilityName(student.disabilityCategory)}</div><div><span class="font-medium">Generated:</span> ${new Date().toLocaleDateString()}</div></div></div>
                        <!-- PLAAFP -->
                        <div><h3>Present Levels (PLAAFP)</h3><p class="text-sm whitespace-pre-wrap">${student.currentPerformance ? escapeHtml(student.currentPerformance) : "<em>Not specified</em>"}</p></div>
                        <!-- Accommodations -->
                        <div><h3>Accommodations & Modifications</h3><p class="text-sm whitespace-pre-wrap">${student.specialAccommodations ? escapeHtml(student.specialAccommodations) : "<em>Not specified</em>"}</p></div>
                        <!-- Services -->
                        <div><h3>Services & Supports</h3><p class="text-sm whitespace-pre-wrap">${student.servicesSupports ? escapeHtml(student.servicesSupports) : "<em>Not specified</em>"}</p></div>
                        <!-- Goals -->
                        <div>
                            <h3>Measurable Annual Goals</h3>
                            <div id="preview-goals-list" class="space-y-4">
                                ${student.iepGoals && student.iepGoals.length > 0 ? student.iepGoals.map((goal, index) => `
                                    <div class="goal-item p-3 border border-base-300 dark:border-dark-300 rounded-md bg-base-100 dark:bg-dark-200 relative group shadow-sm" data-goal-id="${goal.id}" data-goal-index="${index + 1}">
                                        <div class="flex justify-between items-start mb-1">
                                            <h4 class="font-medium text-sm">Goal ${index + 1}${goal.standard ? ` <span class="text-xs font-normal text-gray-500 dark:text-gray-400">(Std: ${goal.standard})</span>` : ''}</h4>
                                            <div class="absolute top-1 right-1 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                 <button type="button" class="refine-goal-btn text-gray-400 hover:text-primary-default p-1 rounded-full bg-base-200 dark:bg-dark-300" title="Refine Goal with AI" aria-label="Refine Goal ${index + 1}"><svg class="h-4 w-4"><use href="#icon-edit"/></svg></button>
                                                 <button type="button" class="delete-goal-btn text-gray-400 hover:text-danger-default p-1 rounded-full bg-base-200 dark:bg-dark-300" title="Delete Goal" aria-label="Delete Goal ${index + 1}"><svg class="h-4 w-4"><use href="#icon-trash"/></svg></button>
                                            </div>
                                        </div>
                                        <p class="text-sm whitespace-pre-wrap mb-2">${escapeHtml(goal.text)}</p>
                                        <p class="text-xs text-gray-500 dark:text-gray-400">Added: ${goal.date || 'N/A'}</p>
                                        <!-- Progress Notes -->
                                        <div class="mt-3 border-t border-base-300 dark:border-dark-300 pt-2">
                                             <div class="flex justify-between items-center"><button type="button" class="toggle-notes-btn btn-link text-xs flex items-center gap-1" aria-expanded="false" aria-controls="notes-${goal.id}">Progress Notes (${goal.progressNotes?.length || 0}) <svg class="h-3 w-3 transition-transform"><use href="#icon-chevron-down"/></svg></button><button type="button" class="add-note-btn btn btn-xs btn-primary-outline" aria-label="Add note to goal ${index + 1}"><svg class="h-3 w-3 mr-1"><use href="#icon-plus"/></svg>Add Note</button></div>
                                             <ul id="notes-${goal.id}" class="progress-notes-list mt-2 space-y-1 hidden">${renderNotes(goal.progressNotes)}</ul>
                                        </div>
                                    </div>`).join('')
                                : `<p class="text-sm text-gray-500 dark:text-gray-400 italic">No goals created yet.</p>`}
                            </div>
                        </div>
                    </div>`;
             }


            /**
             * Loads chat history into the Session Logs panel.
             */
            function loadChatHistory() {
                if (!elements.historyContent) return;
                elements.historyContent.innerHTML = ''; // Clear
                const target = appState.currentChatTarget;

                if (target && !target.isAdHoc && target.chatHistory) {
                    if (target.chatHistory.length === 0) {
                        elements.historyContent.innerHTML = `<p class="history-empty-msg">No chat history for "${target.name}".</p>`;
                    } else {
                        target.chatHistory.forEach(message => elements.historyContent.appendChild(createHistoryMessageElement(message)));
                        elements.historyContent.scrollTop = elements.historyContent.scrollHeight; // Scroll to bottom
                    }
                } else {
                    elements.historyContent.innerHTML = `<p class="history-empty-msg">Select a student or saved group to view history.</p>`;
                }
                // Apply common style to empty messages
                elements.historyContent.querySelectorAll('.history-empty-msg').forEach(el => el.classList.add('text-center', 'text-gray-500', 'dark:text-gray-400', 'italic', 'py-4'));
            }

            /**
             * Creates an HTML element for a single message in the history panel.
             * @param {object} message - The message object { role, content, timestamp }.
             * @returns {HTMLElement} The message div element.
             */
            function createHistoryMessageElement(message) {
                 const messageDiv = document.createElement('div');
                 messageDiv.className = 'mb-4 border-b border-base-300 dark:border-dark-300 pb-4 last:border-b-0 animate-fade-in';
                 
                 // Only make user messages clickable to restore state
                 if (message.role === 'user') {
                     messageDiv.classList.add('cursor-pointer', 'hover:bg-base-200', 'dark:hover:bg-dark-300', 'rounded');
                     messageDiv.setAttribute('role', 'button');
                     messageDiv.setAttribute('tabindex', '0');
                     messageDiv.setAttribute('aria-label', 'Restore to this message');
                     messageDiv.setAttribute('title', 'Click to restore chat to this point');
                     
                     // Add click handler to restore state to this message
                     messageDiv.addEventListener('click', () => {
                         if (appState.currentChatTarget && appState.currentChatTarget.chatHistory) {
                             // Find the index of this message in the chat history
                             const messageIndex = appState.currentChatTarget.chatHistory.findIndex(m => 
                                 m.role === message.role && 
                                 m.content === message.content && 
                                 m.timestamp === message.timestamp
                             );
                             
                             if (messageIndex >= 0) {
                                 // Keep history up to and including this message
                                 appState.currentChatTarget.chatHistory = appState.currentChatTarget.chatHistory.slice(0, messageIndex + 1);
                                 saveStateToLocalStorage();
                                 // Refresh UI
                                 elements.chatMessages.innerHTML = '';
                                 appState.currentChatTarget.chatHistory.forEach(msg => addMessage(msg.role, msg.content));
                                 updatePreview();
                                 loadChatHistory();
                                 showToast('Chat restored to selected message', 'success');
                             }
                         }
                     });
                 }
                 
                 const bubbleDiv = document.createElement('div');
                 bubbleDiv.className = 'p-3 rounded-lg text-sm max-w-full relative group chat-bubble'; // Added chat-bubble
                 const copyBtnHTML = `<button type="button" class="copy-btn" title="Copy message" aria-label="Copy message"><svg class="h-3 w-3 text-gray-600 dark:text-gray-400"><use href="#icon-copy"/></svg></button>`;

                 if (message.role === 'user') {
                     bubbleDiv.classList.add('bg-blue-100', 'dark:bg-blue-900', 'dark:bg-opacity-40', 'ml-auto', 'w-fit', 'max-w-[85%]');
                     bubbleDiv.textContent = message.content;
                 } else { // assistant
                     bubbleDiv.classList.add('bg-gray-100', 'dark:bg-gray-700', 'w-fit', 'max-w-[85%]');
                     try { bubbleDiv.innerHTML = marked.parse(message.content || '') + copyBtnHTML; } catch (e) { console.error("Marked parse error:", e); bubbleDiv.textContent = message.content + ' (Markdown Error)'; }
                     bubbleDiv.querySelectorAll('script, style, iframe, onerror, onload').forEach(el => el.remove()); // Basic sanitation
                 }

                 const timeDiv = document.createElement('div');
                 timeDiv.className = `text-xs text-gray-500 dark:text-gray-400 mt-1 ${message.role === 'user' ? 'text-right' : 'text-left'}`;
                 timeDiv.textContent = message.timestamp ? new Date(message.timestamp).toLocaleString() : 'Timestamp N/A';

                 messageDiv.appendChild(bubbleDiv);
                 messageDiv.appendChild(timeDiv);
                 return messageDiv;
            }

            /**
             * Adds a message to the chat interface.
             * @param {string} role - 'user' or 'assistant'.
             * @param {string} content - The message content (text for user, markdown for assistant).
             */
            function addMessage(role, content) {
                if (!elements.chatMessages) return;
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${role} flex mb-3 group animate-fade-in ${role === 'user' ? 'justify-end' : 'justify-start'}`;
                const bubbleWrap = document.createElement('div');
                bubbleWrap.className = 'flex items-end gap-2 max-w-[90%]'; // Allow slightly wider bubbles
                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = `chat-bubble inline-block rounded-lg p-3 text-sm leading-relaxed relative shadow-sm ${role === 'user' ? 'bg-primary-default text-white rounded-br-none' : 'bg-base-100 dark:bg-dark-300 text-base-content dark:text-dark-content rounded-bl-none'}`;

                const copyBtnHTML = `<button type="button" class="copy-btn" title="Copy message" aria-label="Copy message"><svg class="h-3 w-3 text-gray-600 dark:text-gray-400"><use href="#icon-copy"/></svg></button>`;

                if (role === 'user') {
                    bubbleDiv.textContent = content;
                } else { // assistant
                    try { bubbleDiv.innerHTML = marked.parse(content || '') + copyBtnHTML; } catch (e) { console.error("Marked parse error:", e); bubbleDiv.textContent = content + ' (Markdown Error)'; }
                    bubbleDiv.querySelectorAll('script, style, iframe, onerror, onload').forEach(el => el.remove()); // Basic sanitation
                    bubbleDiv.setAttribute('id', 'latest-response');
                }

                bubbleWrap.appendChild(bubbleDiv);
                messageDiv.appendChild(bubbleWrap);
                elements.chatMessages.appendChild(messageDiv);
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight; // Scroll to bottom

                const previousLatest = elements.chatMessages.querySelector('#latest-response:not(:last-child)');
                if (previousLatest) previousLatest.removeAttribute('id');
            }

            /**
             * Updates the content of the latest assistant message bubble during streaming (if implemented).
             * @param {string} content - The current accumulated content.
             * @param {boolean} isFinal - Whether this is the last update for the message.
             */
            function updateStreamingMessage(content, isFinal = false) {
                 let latestResponse = $('#latest-response');
                 if (!latestResponse) { addMessage('assistant', ''); latestResponse = $('#latest-response'); if (!latestResponse) return; }

                 const copyBtnExists = latestResponse.querySelector('.copy-btn');
                 const copyBtnHTML = copyBtnExists ? '' : `<button type="button" class="copy-btn" title="Copy message" aria-label="Copy message"><svg class="h-3 w-3 text-gray-600 dark:text-gray-400"><use href="#icon-copy"/></svg></button>`;

                 try { latestResponse.innerHTML = marked.parse(content || '') + copyBtnHTML; } catch (e) { console.error("Marked parse error:", e); latestResponse.textContent = content + ' (Markdown Error)'; }
                 latestResponse.querySelectorAll('script, style, iframe, onerror, onload').forEach(el => el.remove());

                 if (isFinal && latestResponse) latestResponse.removeAttribute('id');
                 // Ensure scroll stays at bottom during streaming
                 if (elements.chatMessages && elements.chatMessages.scrollHeight - elements.chatMessages.scrollTop < elements.chatMessages.clientHeight + 100) {
                     elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                 }
            }

            /**
             * Switches the active tab in the main content area.
             * @param {string} tabName - The 'data-tab' value of the tab to activate.
             */
            function switchTab(tabName) {
                elements.chatTabs?.forEach(t => {
                    const isSelected = t.dataset.tab === tabName;
                    t.classList.toggle('active', isSelected);
                    t.classList.toggle('text-primary-default', isSelected);
                    t.classList.toggle('border-primary-default', isSelected);
                    t.classList.toggle('border-b-2', isSelected);
                    t.classList.toggle('text-gray-500', !isSelected);
                    t.classList.toggle('dark:text-gray-400', !isSelected);
                    t.setAttribute('aria-selected', isSelected.toString());
                });

                if (elements.chatPanel) elements.chatPanel.classList.toggle('hidden', tabName !== 'chat');
                if (elements.previewPanel) elements.previewPanel.classList.toggle('hidden', tabName !== 'preview');
                if (elements.historyPanel) elements.historyPanel.classList.toggle('hidden', tabName !== 'history');

                if (tabName === 'preview') updatePreview();
                if (tabName === 'history') loadChatHistory();
            }

            /**
             * Switches the active AI model.
             * @param {string} modelName - 'gemini' or 'huggingface'.
             * @param {boolean} [showMessage=true] - Whether to add a confirmation message to chat.
             */
            function switchApiModel(modelName, showMessage = true) {
                 API_CONFIG.activeModel = modelName;
                 const isActiveGemini = modelName === 'gemini';
                 const applyStyle = (el, active) => {
                     el?.classList.toggle('bg-primary-default', active); el?.classList.toggle('text-white', active);
                     el?.classList.toggle('bg-base-100', !active); el?.classList.toggle('text-base-content', !active);
                     el?.classList.toggle('dark:bg-dark-200', !active); el?.classList.toggle('dark:text-dark-content', !active);
                     el?.classList.toggle('border-base-300', !active); el?.classList.toggle('dark:border-dark-300', !active);
                 };
                 applyStyle(elements.geminiBtn, isActiveGemini);
                 applyStyle(elements.huggingfaceBtn, !isActiveGemini);
                 // Ensure border styles are correct for HF button
                 elements.huggingfaceBtn?.classList.toggle('border', !isActiveGemini);

                 if (showMessage) { const desc = modelName === 'gemini' ? 'Google Gemini Flash' : 'Hugging Face Mistral'; showToast(`Model switched to ${desc}.`, 'info'); }
                 appState.settings.defaultModel = modelName;
                 saveStateToLocalStorage();
            }

            /**
             * Toggles the visibility of the Add/Edit Student form.
             * @param {boolean | null} [forceState=null] - `true` to show, `false` to hide, `null` to toggle.
             */
            function toggleStudentForm(forceState = null) {
                 if (!elements.studentFormContainer || !elements.toggleStudentFormBtn) return;
                 const shouldBeVisible = forceState !== null ? forceState : elements.studentFormContainer.classList.contains('hidden');
                 elements.studentFormContainer.classList.toggle('hidden', !shouldBeVisible);
                 elements.toggleStudentFormBtn.setAttribute('aria-expanded', shouldBeVisible.toString());
                 elements.toggleStudentFormBtn.innerHTML = shouldBeVisible
                     ? `<svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 12h-15" /></svg> Hide Form`
                     : `<svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg> Add New Student`;
                 if (!shouldBeVisible) clearStudentForm();
            }

            // --- Utility Functions ---
            function clearStudentForm() { elements.studentForm?.reset(); }
            function handleSelectAll(e) { e.preventDefault(); Array.from(elements.studentDropdown.options).forEach(opt => { if (opt.style.display !== 'none') opt.selected = true; }); elements.studentDropdown?.dispatchEvent(new Event('change')); }
            function handleDeselectAll(e) { e.preventDefault(); Array.from(elements.studentDropdown.options).forEach(opt => opt.selected = false); elements.studentDropdown?.dispatchEvent(new Event('change')); }

            /**
             * Handles selection in the single student dropdown.
             * This focuses the AI on a single student across all tabs/elements.
             * Auto-generates and displays the IEP preview for the selected student.
             */
            function handleSingleStudentSelection() {
                const selectedIndex = parseInt(elements.singleStudentDropdown.value, 10);
                
                if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < appState.students.length) {
                    // Clear multi-select and set only this student
                    Array.from(elements.studentDropdown.options).forEach(opt => {
                        opt.selected = parseInt(opt.value, 10) === selectedIndex;
                    });
                    
                    // Update app state
                    appState.selectedStudentIndexes = [selectedIndex];
                    appState.selectedGroupIndex = null;
                    appState.activeContext = 'student';
                    appState.currentChatTarget = appState.students[selectedIndex];
                    
                    // Clear group dropdown
                    if (elements.groupDropdown) elements.groupDropdown.value = "";
                    
                    // Update UI
                    updateUIBasedOnSelection();
                    
                    // Auto-generate and display IEP preview
                    switchTab('preview');
                    updatePreview();
                    
                    showToast(`Focus set to ${appState.currentChatTarget.name} - IEP Preview generated`, 'success');
                } else {
                    // Handle "-- Select a Student --" option
                    // Don't change anything, just show a message
                    showToast('Please select a student to focus on', 'info');
                }
            }
            
            /**
             * Handles the refresh data button click.
             * Updates all views and displays without requiring a page refresh.
             */
            function handleRefreshData() {
                // Save current state
                saveStateToLocalStorage();
                
                // Refresh all UI components
                updateStudentDropdown();
                updateGroupDropdown();
                updateUIBasedOnSelection();
                updatePreview();
                loadChatHistory();
                
                showToast('Data refreshed successfully', 'success');
            }
            function getDisabilityName(code) { return DISABILITY_MAP[code] || code || 'N/A'; }
            function getGradeName(code) { return GRADE_MAP[code] ? `${GRADE_MAP[code]}` : (code === 'K' ? 'Kindergarten' : code || 'N/A'); }
            function generateId(prefix = 'item') { return `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 7)}`; }
            function createAdHocGroupContext(studentIndexes) { return { name: `${studentIndexes.length} selected students`, students: studentIndexes.map(i => appState.students[i]), isAdHoc: true }; }
            function identifyCommonNeeds(students) { /* ... (Placeholder - add logic if needed) ... */ return ''; } // Keep simple for now
            function escapeHtml(unsafe) { return unsafe?.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;") || ''; }
            function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func.apply(this, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

            /**
             * Generates a system prompt tailored to the current context.
             * @param {object | null} context - The current student or group object, or null.
             * @returns {string} The generated system prompt.
             */
            function generateSystemPrompt(context) {
                const currentDate = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                const basePrompt = `You are IEP Assistant Pro, an expert AI specializing in creating high-quality, Indiana-compliant Individualized Education Programs (IEPs). Always begin your responses with "**Date: ${currentDate}**" on its own line, followed by a blank line before your actual response. Your responses should be professional, detailed, objective, and directly relevant to the user's request and the provided context. Adhere strictly to SMART goal principles (Specific, Measurable, Achievable, Relevant, Time-bound). When asked for goals or objectives, clearly label them starting with "SMART Goal:" or "Objective:". Use Markdown for formatting (bolding, lists).`;

                if (context?.isAdHoc) {
                    const studentSummaries = context.students.map(s => `${s.name} (Gr ${getGradeName(s.grade)}, ${getDisabilityName(s.disabilityCategory)})`).join('; ');
                    return `${basePrompt}\n\nYou are currently assisting with an ad-hoc group of students: ${studentSummaries}. Provide general advice, strategies, or adaptable goal ideas applicable to diverse needs. Acknowledge you are working with a group. Do not generate specific IEP content unless asked for examples.`;
                } else if (context?.studentIndexes) { // Saved group
                    const group = context;
                    const studentDetails = appState.students.filter((_, index) => group.studentIndexes.includes(index)).map(s => `${s.name} (Gr ${getGradeName(s.grade)}, ${getDisabilityName(s.disabilityCategory)})`).join('; ');
                    return `${basePrompt}\n\nYou are currently assisting with the saved student group named "${group.name}". This group includes: ${studentDetails}. Respond considering this group context. Generate adaptable goal ideas or discuss strategies relevant to the group.`;
                } else if (context?.id?.startsWith('student')) { // Single student
                    const student = context;
                    let prompt = `${basePrompt}\n\nYou are working with student: ${student.name}`;
                    prompt += student.grade ? `, a ${getGradeName(student.grade)} student` : '';
                    prompt += student.disabilityCategory ? ` with ${getDisabilityName(student.disabilityCategory)}.` : '.';
                    if (student.currentPerformance) prompt += `\nStudent's Present Levels (PLAAFP): ${student.currentPerformance}`;
                    if (student.specialAccommodations) prompt += `\nStudent's Accommodations/Modifications: ${student.specialAccommodations}`;
                    if (student.servicesSupports) prompt += `\nStudent's Services/Supports: ${student.servicesSupports}`;
                    prompt += `\nFocus your responses on this specific student's needs and context.`;
                    return prompt;
                } else { // No context
                    return `${basePrompt}\n\nNo specific student or group is selected. Please ask the user to select a context or provide general information about IEPs or Indiana standards.`;
                }
            }

            let thinkingInterval;
            /** Starts the "Thinking..." indicator animation. */
            function startThinkingIndicator() {
                if (thinkingInterval) clearInterval(thinkingInterval);
                if (elements.chatStatus) elements.chatStatus.classList.remove('hidden');
                let msgIndex = 0;
                const updateText = () => {
                    const statusText = elements.chatStatus?.querySelector('.status-text');
                    if (statusText) {
                        statusText.textContent = AI_THINKING_MESSAGES[msgIndex % AI_THINKING_MESSAGES.length];
                    } else {
                        // Log a warning if the element wasn't found, helps debugging
                        console.warn("UI Warning: status-text element not found when trying to update thinking indicator.");
                        clearInterval(thinkingInterval); // Stop trying if element is missing
                    }
                    msgIndex++;
                };
                // Check if statusText exists before setting interval
                if (elements.chatStatus?.querySelector('.status-text')) {
                     updateText(); // Initial text
                     thinkingInterval = setInterval(updateText, 2000); // Change message every 2s
                } else {
                    console.warn("UI Warning: status-text element not found, cannot start thinking indicator.");
                    elements.chatStatus?.classList.add('hidden'); // Ensure container is hidden if text can't be set
                }
            }

            /** Stops the "Thinking..." indicator. */
            function stopThinkingIndicator() {
                clearInterval(thinkingInterval);
                thinkingInterval = null;
                if (elements.chatStatus) elements.chatStatus.classList.add('hidden');
            }

            /** Sets up auto-resizing for the chat textarea. */
            function setupAutoResizeTextarea() { 
                elements.userMessageInput?.addEventListener('input', () => adjustTextareaHeight(elements.userMessageInput)); 
                adjustTextareaHeight(elements.userMessageInput);
            }
            
            /** Adjusts textarea height based on content. */
            function adjustTextareaHeight(textarea) { 
                if (!textarea) return; 
                textarea.style.height = 'auto'; 
                const maxHeight = 150; 
                textarea.style.height = `${Math.min(textarea.scrollHeight, maxHeight)}px`; 
            }

            // --- Slash Commands Menu ---
            /**
             * Shows the slash commands menu.
             */
            function showSlashCommandsMenu() {
                if (!elements.slashCommandsMenu || !elements.userMessageInput) return;
                
                const input = elements.userMessageInput;
                const value = input.value;
                
                if (!value.startsWith('/')) {
                    hideSlashCommandsMenu();
                    return;
                }
                
                const query = value.substring(1); // Remove the leading slash
                
                // Update menu content
                updateSlashCommandsMenu(query);
                
                // Show the menu
                elements.slashCommandsMenu.classList.remove('hidden');
            }

            /**
             * Updates the slash commands menu items based on the query.
             * @param {string} query - The search query.
             */
            function updateSlashCommandsMenu(query) {
                if (!elements.slashCommandsMenu) return;
                
                // Clear existing items
                elements.slashCommandsMenu.innerHTML = '';
                
                // Filter commands based on query
                const filteredCommands = SLASH_COMMANDS.filter(cmd => 
                    cmd.command.toLowerCase().includes(query.toLowerCase()) ||
                    cmd.description.toLowerCase().includes(query.toLowerCase()) ||
                    cmd.options.some(opt => opt.toLowerCase().includes(query.toLowerCase()))
                );
                
                if (filteredCommands.length === 0) {
                    const noResults = document.createElement('div');
                    noResults.className = 'slash-menu-item';
                    noResults.textContent = 'No commands found';
                    elements.slashCommandsMenu.appendChild(noResults);
                    return;
                }
                
                // Add command items to menu
                filteredCommands.forEach(cmd => {
                    const item = document.createElement('div');
                    item.className = 'slash-menu-item';
                    item.setAttribute('role', 'option');
                    item.setAttribute('data-command', cmd.command);
                    
                    const commandSpan = document.createElement('div');
                    commandSpan.className = 'slash-menu-command';
                    commandSpan.textContent = cmd.command;
                    
                    const descSpan = document.createElement('div');
                    descSpan.className = 'slash-menu-description';
                    descSpan.textContent = cmd.description;
                    
                    item.appendChild(commandSpan);
                    item.appendChild(descSpan);
                    
                    if (cmd.options.length > 0) {
                        const optionsSpan = document.createElement('div');
                        optionsSpan.className = 'slash-menu-options';
                        optionsSpan.textContent = `Options: ${cmd.options.join(', ')}`;
                        item.appendChild(optionsSpan);
                    }
                    
                    item.addEventListener('click', () => {
                        selectCommand(cmd.command);
                    });
                    
                    elements.slashCommandsMenu.appendChild(item);
                });
                
                // Select first item by default
                const firstItem = elements.slashCommandsMenu.querySelector('.slash-menu-item');
                if (firstItem) {
                    firstItem.classList.add('active');
                }
            }

            /**
             * Selects a command from the menu and inserts it into the input.
             * @param {string} command - The command to select.
             */
            function selectCommand(command) {
                if (!elements.userMessageInput) return;
                
                elements.userMessageInput.value = `${command} `;
                elements.userMessageInput.focus();
                
                // Adjust the height of the textarea
                adjustTextareaHeight(elements.userMessageInput);
                
                // Hide the menu
                hideSlashCommandsMenu();
            }

            /**
             * Hides the slash commands menu.
             */
            function hideSlashCommandsMenu() {
                if (elements.slashCommandsMenu) {
                    elements.slashCommandsMenu.classList.add('hidden');
                }
            }

            /**
             * Handles input changes in the chat textarea.
             */
            function handleChatInputChange(e) {
                const value = e.target.value;
                
                if (value.startsWith('/')) {
                    showSlashCommandsMenu();
                } else {
                    hideSlashCommandsMenu();
                }
            }

            /**
             * Handles keydown events in the chat textarea.
             * @param {KeyboardEvent} e - The keydown event.
             */
            function handleChatInputKeydown(e) {
                // If slash menu is visible, handle navigation
                if (!elements.slashCommandsMenu || elements.slashCommandsMenu.classList.contains('hidden')) {
                    // If Enter pressed without Shift, and not in slash menu, submit the form
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        elements.chatForm?.dispatchEvent(new Event('submit'));
                    }
                    return;
                }
                
                // Get all menu items and the currently active one
                const items = elements.slashCommandsMenu.querySelectorAll('.slash-menu-item');
                const activeItem = elements.slashCommandsMenu.querySelector('.slash-menu-item.active');
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        navigateMenu(items, activeItem, 1);
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        navigateMenu(items, activeItem, -1);
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        if (activeItem) {
                            const command = activeItem.getAttribute('data-command');
                            if (command) {
                                selectCommand(command);
                            }
                        }
                        break;
                        
                    case 'Escape':
                        e.preventDefault();
                        hideSlashCommandsMenu();
                        break;
                        
                    case 'Tab':
                        e.preventDefault();
                        if (activeItem) {
                            const command = activeItem.getAttribute('data-command');
                            if (command) {
                                selectCommand(command);
                            }
                        }
                        break;
                }
            }

            /**
             * Navigates the slash commands menu.
             * @param {NodeList} items - All menu items.
             * @param {HTMLElement} activeItem - The currently active item.
             * @param {number} direction - The direction to navigate (1 for down, -1 for up).
             */
            function navigateMenu(items, activeItem, direction) {
                if (items.length === 0) return;
                
                // If no active item, select the first or last based on direction
                if (!activeItem) {
                    items[direction > 0 ? 0 : items.length - 1].classList.add('active');
                    return;
                }
                
                // Get the index of the active item
                let currentIndex = Array.from(items).indexOf(activeItem);
                
                // Calculate the new index
                let newIndex = (currentIndex + direction) % items.length;
                if (newIndex < 0) newIndex = items.length - 1;
                
                // Update active class
                activeItem.classList.remove('active');
                items[newIndex].classList.add('active');
                
                // Scroll into view if needed
                items[newIndex].scrollIntoView({ block: 'nearest' });
            }
            
            // --- Chat Command Processing ---
            /**
             * Processes chat commands starting with '/'.
             * @param {string} message - The full command message.
             * @returns {boolean} True if a command was recognized and handled, false otherwise.
             */
            function processChatCommand(message) {
                if (!message.startsWith('/')) return false;
                
                // Split the message into command and arguments
                const parts = message.trim().split(' ');
                const commandText = parts[0].toLowerCase();
                const args = parts.slice(1);
                
                // Find the matching command
                const command = SLASH_COMMANDS.find(cmd => cmd.command === commandText);
                
                if (command) {
                    addMessage('user', message); // Show original command in chat
                    
                    try {
                        // Special handling for '/gen complete' command
                        if (commandText === '/gen' && args[0] === 'complete') {
                            handleGenerateIEP();
                            return true;
                        }
                        
                        // Execute the command
                        command.execute(args);
                        return true;
                    } catch (error) {
                        console.error(`Error executing command ${commandText}:`, error);
                        showToast(`Error: ${error.message}`, 'error');
                        return true; // Consider it handled even if it failed
                    }
                }
                
                showToast(`Unknown command: ${commandText}`, 'warning');
                return false; // Not handled
            }
            
            /**
             * Handles the /gen command to generate specific IEP sections.
             * @param {string} sectionType - 'plaafp', 'accom', 'services', 'goal'.
             * @param {string} details - Optional user-provided details/prompt.
             */
            function handleGenerateSectionCommand(sectionType, details) {
                if (appState.activeContext !== 'student' || !appState.currentChatTarget) {
                    showToast("Select a single student first.", 'warning'); 
                    return;
                }
                const student = appState.currentChatTarget;
                let sectionName = '';
                let promptPrefix = '';

                switch (sectionType) {
                    case 'plaafp':
                        sectionName = 'Present Levels (PLAAFP)';
                        promptPrefix = `Generate a detailed PLAAFP section for ${student.name}. Consider their grade (${getGradeName(student.grade)}), disability (${getDisabilityName(student.disabilityCategory)}), current PLAAFP (${student.currentPerformance || 'N/A'}), and any known strengths/weaknesses.`;
                        break;
                    case 'accom': case 'accommodations':
                        sectionName = 'Accommodations & Modifications';
                        promptPrefix = `Suggest appropriate Accommodations and Modifications for ${student.name}, considering their grade (${getGradeName(student.grade)}), disability (${getDisabilityName(student.disabilityCategory)}), current accommodations (${student.specialAccommodations || 'N/A'}), and PLAAFP (${student.currentPerformance || 'N/A'}). Focus on practical classroom and testing supports.`;
                        break;
                    case 'services': case 'supports':
                        sectionName = 'Services & Supports';
                        promptPrefix = `Suggest potential related Services and Supports for ${student.name} based on their disability (${getDisabilityName(student.disabilityCategory)}), current services (${student.servicesSupports || 'N/A'}), and PLAAFP (${student.currentPerformance || 'N/A'}). Include frequency/duration examples if appropriate (e.g., Speech 2x/week).`;
                        break;
                    case 'goal':
                        sectionName = 'SMART Goal';
                        promptPrefix = `Create a measurable SMART goal for ${student.name}, a ${getGradeName(student.grade)} student with ${getDisabilityName(student.disabilityCategory)}. Consider their PLAAFP (${student.currentPerformance || 'N/A'}) and accommodations (${student.specialAccommodations || 'N/A'}).`;
                        break;
                    case 'complete':
                        // This is handled separately by redirecting to handleGenerateIEP()
                        handleGenerateIEP();
                        return;
                    default:
                        showToast(`Unknown section type: ${sectionType}. Use plaafp, accom, services, goal, or complete.`, 'warning');
                        return;
                }

                const fullPrompt = `${promptPrefix} ${details ? `Additional context: ${details}` : ''}\n\nFormat the output clearly, starting with "${sectionName}:".`;
                // Send to AI - response processing will handle updating the student data
                sendToChatbot(fullPrompt, student);
            }


            // --- Data I/O (CSV, JSON) ---
             function handleCsvUpload(e) {
                 const file = e.target.files?.[0]; if (!file) return;
                 showToast("Processing CSV...", 'info');
                 // Find the button within the modal if it exists
                 const btn = document.querySelector('#importCsvBtn'); // Assuming button in modal has this ID
                 if (btn) { btn.disabled = true; btn.innerHTML += '<span class="button-spinner"></span>'; }

                 Papa.parse(file, {
                     header: true, skipEmptyLines: true, dynamicTyping: false, // Keep all as strings initially
                     complete: (results) => {
                         if (btn) { btn.disabled = false; btn.querySelector('.button-spinner')?.remove(); }
                         handleParsedFileData(results, 'CSV');
                         closeModal(); // Close settings modal after successful import
                     },
                     error: (error) => {
                         if (btn) { btn.disabled = false; btn.querySelector('.button-spinner')?.remove(); }
                         console.error("CSV Parsing Failed:", error);
                         showToast(`CSV Error: ${error.message}`, 'error');
                     }
                 });
                 e.target.value = null; // Reset file input
             }

             function downloadCsvData() {
                 if (appState.students.length === 0) { showToast("No student data to export.", 'warning'); return; }
                 // Include only core fields relevant for CSV import/export
                 const dataToExport = appState.students.map(s => ({
                     studentName: s.name,
                     grade: s.grade,
                     disabilityCategory: s.disabilityCategory,
                     currentPerformance: s.currentPerformance,
                     specialAccommodations: s.specialAccommodations,
                     servicesSupports: s.servicesSupports
                 }));
                 try {
                     const csv = Papa.unparse(dataToExport);
                     downloadFile(csv, `iep_students_${getDateString()}.csv`, 'text/csv;charset=utf-8;');
                     showToast(`CSV data downloaded (${appState.students.length} records).`, 'success');
                 } catch (error) {
                     console.error("CSV Generation Error:", error);
                     showToast(`CSV Export Error: ${error.message}`, 'error');
                 }
             }

            function downloadJsonData(dataType = 'all') { // dataType can be 'all', 'students', 'groups'
                let dataToExport;
                let filename;
                switch(dataType) {
                    case 'students':
                        if (appState.students.length === 0) { showToast("No student data to export.", 'warning'); return; }
                        dataToExport = appState.students;
                        filename = `iep_students_${getDateString()}.json`;
                        break;
                    case 'groups':
                         if (appState.studentGroups.length === 0) { showToast("No group data to export.", 'warning'); return; }
                        dataToExport = appState.studentGroups;
                        filename = `iep_groups_${getDateString()}.json`;
                        break;
                    case 'all':
                    default:
                         dataToExport = { students: appState.students, studentGroups: appState.studentGroups, settings: appState.settings, appVersion: APP_VERSION };
                         filename = `iep_assistant_backup_${getDateString()}.json`;
                         break;
                }

                try {
                    const jsonString = JSON.stringify(dataToExport, null, 2); // Pretty print JSON
                    downloadFile(jsonString, filename, 'application/json;charset=utf-8;');
                    showToast(`${filename} downloaded successfully.`, 'success');
                } catch (error) {
                    console.error("JSON Generation Error:", error);
                    showToast(`JSON Export Error: ${error.message}`, 'error');
                }
            }
            
            /**
             * Handles JSON file upload with improved error handling
             */
            function handleJsonUpload(e) {
                const file = e.target.files?.[0]; 
                if (!file) return;
                
                showToast("Processing JSON backup...", 'info');
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        // Try to parse the JSON data
                        const jsonData = JSON.parse(event.target.result);
                        
                        // Check if it's a full backup by looking for expected properties
                        if (jsonData.appVersion && Array.isArray(jsonData.students) && Array.isArray(jsonData.studentGroups)) {
                            // It's a full backup, confirm with the user that this will overwrite data
                            if (confirm(`This will restore a full backup from v${jsonData.appVersion}. All current data will be overwritten. Continue?`)) {
                                // Save directly to localStorage
                                storage.setItem(STORAGE_KEY, event.target.result);
                                showToast("Backup restored! Reloading page...", 'success');
                                
                                // Reload the page after a brief delay to show the success message
                                setTimeout(() => {
                                    window.location.reload();
                                }, 1500);
                            } else {
                                showToast("Restore canceled.", 'info');
                            }
                        } 
                        // Check if it's just a students array
                        else if (Array.isArray(jsonData) && jsonData.length > 0 && jsonData[0]?.id?.includes('student')) {
                            handleParsedFileData({ data: jsonData }, 'JSON (Students Only)');
                            closeModal();
                        }
                        // Check if it's just a groups array
                        else if (Array.isArray(jsonData) && jsonData.length > 0 && jsonData[0]?.id?.includes('group')) {
                            handleParsedFileData({ data: jsonData }, 'JSON (Groups Only)');
                            closeModal();
                        }
                        else {
                            throw new Error("The JSON file format was not recognized. Make sure it's a valid IEP Assistant backup file.");
                        }
                    } catch (error) {
                        console.error("JSON processing error:", error);
                        showToast(`Error: ${error.message}`, 'error');
                    }
                };
                
                reader.onerror = () => {
                    showToast("Failed to read the file. Please try again.", 'error');
                };
                
                // Start reading the file
                reader.readAsText(file);
                
                // Reset the file input
                e.target.value = null;
            }

            /**
             * Processes parsed data from CSV or JSON (student/group arrays).
             * Merges data, preferring existing records based on name.
             * @param {object} results - The parsed data object (like PapaParse results).
             * @param {string} sourceType - 'CSV', 'JSON (Students Only)', etc.
             */
            function handleParsedFileData(results, sourceType) {
                 if (!results || !Array.isArray(results.data) || results.data.length === 0) { showToast(`${sourceType} file contained no valid data.`, 'warning'); return; }

                 let added = 0, updated = 0, skipped = 0;
                 const isStudentData = sourceType.includes('Student') || sourceType === 'CSV'; // CSV is assumed to be student data
                 const isGroupData = sourceType.includes('Group');

                 results.data.forEach(item => {
                     if (isStudentData) {
                         const name = item.studentName?.trim() || item.name?.trim(); // Allow 'name' from JSON
                         if (!name) { skipped++; return; } // Skip items without a name

                         const studentData = {
                             name: name,
                             grade: item.grade || '',
                             disabilityCategory: item.disabilityCategory || '',
                             currentPerformance: item.currentPerformance || '',
                             specialAccommodations: item.specialAccommodations || '',
                             servicesSupports: item.servicesSupports || '',
                             // Import goals/history only from JSON, not CSV
                             iepGoals: sourceType.includes('JSON') ? (item.iepGoals || []) : [],
                             chatHistory: sourceType.includes('JSON') ? (item.chatHistory || []) : [],
                             id: item.id || generateId('student') // Use imported ID if available
                         };

                         const existingIndex = appState.students.findIndex(s => s.name.toLowerCase() === name.toLowerCase());
                         if (existingIndex >= 0) {
                             // Merge: Keep existing ID, merge other fields (preferring imported data for core fields)
                             appState.students[existingIndex] = {
                                 ...appState.students[existingIndex], // Keep original ID, potentially older goals/history if not in import
                                 ...studentData, // Overwrite core fields, potentially goals/history if in import
                                 id: appState.students[existingIndex].id // Ensure original ID is kept
                             };
                             updated++;
                         } else {
                             appState.students.push(studentData); // Add as new, using imported ID or generating one
                             added++;
                         }
                     } else if (isGroupData) {
                         const name = item.name?.trim();
                         if (!name || !Array.isArray(item.studentIndexes)) { skipped++; return; } // Basic validation

                         const groupData = {
                             name: name,
                             studentIndexes: item.studentIndexes || [],
                             chatHistory: item.chatHistory || [],
                             id: item.id || generateId('group')
                         };

                         const existingIndex = appState.studentGroups.findIndex(g => g.name.toLowerCase() === name.toLowerCase());
                         if (existingIndex >= 0) {
                             appState.studentGroups[existingIndex] = {
                                 ...appState.studentGroups[existingIndex],
                                 ...groupData,
                                 id: appState.studentGroups[existingIndex].id
                             };
                             updated++;
                         } else {
                             appState.studentGroups.push(groupData);
                             added++;
                         }
                     }
                 });

                 saveStateToLocalStorage();
                 if (isStudentData) updateStudentDropdown();
                 if (isGroupData) updateGroupDropdown();
                 let message = `${sourceType} Processed! Added: ${added}, Updated: ${updated}.`;
                 if (skipped > 0) message += ` Skipped: ${skipped}.`;
                 showToast(message, 'success');
                 addMessage('assistant', `Imported/Updated ${added + updated} records from ${sourceType}. ${skipped > 0 ? `Skipped ${skipped} invalid records.` : ''}`);
             }


            /**
             * Helper to trigger file download.
             * @param {string} content - The file content.
             * @param {string} filename - The desired filename.
             * @param {string} contentType - The MIME type.
             */
            function downloadFile(content, filename, contentType) {
                 const blob = new Blob([content], { type: contentType });
                 const url = URL.createObjectURL(blob);
                 const link = document.createElement('a');
                 link.href = url; link.download = filename;
                 document.body.appendChild(link); link.click(); document.body.removeChild(link);
                 URL.revokeObjectURL(url);
            }
            /** Gets a date string for filenames. */
            function getDateString() { return new Date().toISOString().slice(0, 10); }
            /** Gets the first value if all items in array have the same value for a key, else returns null */
            function getCommonValue(items, key) { if (!items || items.length === 0) return null; const firstValue = items[0][key]; return items.every(item => item[key] === firstValue) ? firstValue : null; }


            // --- PDF Export ---
            function exportToPDF() {
                 if (appState.activeContext !== 'student' || !appState.currentChatTarget) { showToast("Select a single student to export.", 'warning'); return; }
                 const student = appState.currentChatTarget;
                 const btn = elements.previewPdfBtn;
                 if (!btn) { showToast("PDF export button not found.", 'error'); return; }
                 btn.disabled = true; btn.innerHTML += '<span class="button-spinner"></span>';
                 showToast(`Generating PDF for ${student.name}...`, 'info');

                 setTimeout(() => { // Allow UI to update
                     try {
                         const { jsPDF } = window.jspdf; const doc = new jsPDF({ unit: 'mm', format: 'a4' });
                         const pageHeight = doc.internal.pageSize.getHeight(); const pageWidth = doc.internal.pageSize.getWidth();
                         const margin = 15; const maxLineWidth = pageWidth - (margin * 2); let currentY = margin + 5; let pageNum = 1;

                         const checkBreak = (y, needed = 10) => { if (y + needed > pageHeight - margin) { addFooter(doc, pageNum, pageHeight, pageWidth, margin); doc.addPage(); pageNum++; addFooter(doc, pageNum, pageHeight, pageWidth, margin); return margin; } return y; };
                         const addText = (text, x, y, options = {}) => { const { size = 10, style = 'normal', maxWidth = maxLineWidth, color = [0, 0, 0], align } = options; doc.setFontSize(size); doc.setFont(undefined, style); doc.setTextColor(color[0], color[1], color[2]); const lines = doc.splitTextToSize(text || '', maxWidth); doc.text(lines, align === 'center' ? pageWidth / 2 : x, y, { align: align || 'left', lineHeightFactor: 1.15 }); return y + (lines.length * (size * 0.35 * 1.15)); };
                         const addHeading = (text, y) => { y = checkBreak(y, 12); doc.setFontSize(12); doc.setFont(undefined, 'bold'); doc.setTextColor(appState.settings.darkMode === 'dark' ? 200 : 50); doc.text(text, margin, y + 5); doc.setDrawColor(appState.settings.darkMode === 'dark' ? 100 : 200).setLineWidth(0.3).line(margin, y + 7, pageWidth - margin, y + 7); return y + 10; };
                         const addFooter = (d, pNum, pgH, pgW, mgn) => { d.setFontSize(8).setTextColor(150).text(`Page ${pNum}`, pgW - mgn, pgH - mgn + 5, { align: 'right' }); d.text(`IEP Assistant Pro v${APP_VERSION}`, mgn, pgH - mgn + 5); };

                         // --- Content ---
                         addFooter(doc, pageNum, pageHeight, pageWidth, margin);
                         currentY = addText('INDIANA DEPARTMENT OF EDUCATION', 0, currentY, { size: 14, style: 'bold', color: [40, 53, 147], align: 'center', maxWidth: pageWidth });
                         currentY = addText('INDIVIDUALIZED EDUCATION PROGRAM (IEP)', 0, currentY + 1, { size: 12, style: 'bold', align: 'center', maxWidth: pageWidth }); currentY += 8;

                         const infoStartY = currentY; let col1Y = infoStartY + 5; let col2Y = infoStartY + 5;
                         col1Y = addText(`Student: ${student.name || '-'}`, margin + 3, col1Y, { size: 10, style: 'bold' }); col1Y = addText(`Grade: ${getGradeName(student.grade)}`, margin + 3, col1Y + 0.5);
                         col2Y = addText(`Disability: ${getDisabilityName(student.disabilityCategory)}`, margin + maxLineWidth / 2, col2Y, {size: 10}); col2Y = addText(`Date: ${new Date().toLocaleDateString()}`, margin + maxLineWidth / 2, col2Y + 0.5);
                         currentY = Math.max(col1Y, col2Y) + 3; doc.setDrawColor(180).setLineWidth(0.2).rect(margin, infoStartY, maxLineWidth, currentY - infoStartY); currentY += 5;

                         currentY = addHeading('Present Levels (PLAAFP)', currentY); currentY = addText(student.currentPerformance || 'Not specified.', margin, currentY, { size: 10 });
                         currentY = addHeading('Accommodations & Modifications', currentY); currentY = addText(student.specialAccommodations || 'Not specified.', margin, currentY, { size: 10 });
                         currentY = addHeading('Services & Supports', currentY); currentY = addText(student.servicesSupports || 'Not specified.', margin, currentY, { size: 10 });

                         currentY = addHeading('Measurable Annual Goals', currentY);
                         if (!student.iepGoals || student.iepGoals.length === 0) { currentY = addText('No goals added.', margin, currentY, { style: 'italic' }); }
                         else {
                             student.iepGoals.forEach((goal, index) => {
                                 currentY = checkBreak(currentY, 20); // Estimate needed space
                                 const goalStartY = currentY;
                                 let goalY = addText(`Goal ${index + 1}:`, margin + 2, goalStartY + 4, { style: 'bold' });
                                 goalY = addText(goal.text || '', margin + 15, goalStartY + 4, { maxWidth: maxLineWidth - 20 });
                                 if (goal.standard) goalY = addText(`Std: ${goal.standard}`, margin + 15, goalY, { size: 9, style: 'italic', color: [80, 80, 80] });
                                 if (goal.date) goalY = addText(`Added: ${goal.date}`, margin + 15, goalY, { size: 9, style: 'italic', color: [80, 80, 80] });

                                 // Add Progress Notes
                                 if (goal.progressNotes?.length) {
                                     goalY = checkBreak(goalY, 8);
                                     goalY = addText(`Notes:`, margin + 15, goalY + 1, { size: 9, style: 'bold' });
                                     // Sort notes newest first for PDF
                                     [...goal.progressNotes].sort((a, b) => new Date(b.date) - new Date(a.date)).forEach(n => {
                                         goalY = checkBreak(goalY, 6);
                                         goalY = addText(`- ${new Date(n.date).toLocaleDateString()}: ${n.note}`, margin + 18, goalY, { size: 9, maxWidth: maxLineWidth - 25 });
                                     });
                                 }
                                 doc.setDrawColor(220).setLineWidth(0.1).rect(margin, goalStartY, maxLineWidth, goalY - goalStartY + 2);
                                 currentY = goalY + 5;
                             });
                         }

                         const totalPages = doc.internal.getNumberOfPages();
                         for (let i = 1; i <= totalPages; i++) { doc.setPage(i); addFooter(doc, i, pageHeight, pageWidth, margin); }
                         doc.setPage(totalPages); addText('Developed in accordance with Indiana Administrative Code 511 IAC 7-42', 0, pageHeight - margin + 10, { size: 8, color: [100, 100, 100], align: 'center', maxWidth: pageWidth });

                         doc.save(`IEP_${student.name.replace(/[^a-z0-9]/gi, '_')}_${getDateString()}.pdf`);
                         showToast(`PDF for ${student.name} generated!`, 'success');
                     } catch (error) { console.error("PDF Generation Error:", error); showToast(`PDF Error: ${error.message}`, 'error');
                     } finally { btn.disabled = false; btn.querySelector('.button-spinner')?.remove(); }
                 }, 50); // Short delay to allow UI update before intensive PDF work
             }


            // --- Modals ---
            function openModal(title, contentHTML, onSave, saveLabel = "Save", modalClass = 'max-w-xl') {
                 closeModal(); // Ensure only one modal is open
                 const modalId = `modal-${generateId()}`;
                 const modal = document.createElement('div');
                 modal.className = 'modal-overlay'; modal.id = modalId;
                 modal.setAttribute('role', 'dialog'); modal.setAttribute('aria-modal', 'true'); modal.setAttribute('aria-labelledby', `${modalId}-title`);
                 modal.innerHTML = `
                    <div class="modal-content ${modalClass} dark:text-dark-content">
                        <div class="flex justify-between items-center mb-4 border-b border-base-300 dark:border-dark-300 pb-2">
                            <h3 id="${modalId}-title" class="text-xl font-semibold text-primary-default">${title}</h3>
                            <button type="button" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 p-1 rounded-full hover:bg-base-200 dark:hover:bg-dark-300" aria-label="Close modal" data-action="close"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></button>
                        </div>
                        <form id="${modalId}-form">
                            ${contentHTML}
                            <div class="flex justify-end gap-3 mt-6 pt-4 border-t border-base-300 dark:border-dark-300">
                                <button type="button" class="btn btn-secondary" data-action="close">Cancel</button>
                                ${onSave ? `<button type="submit" class="btn btn-primary">${saveLabel}</button>` : ''}
                            </div>
                        </form>
                    </div>`;
                 if (elements.modalContainer) {
                    elements.modalContainer.appendChild(modal);
                    const form = modal.querySelector('form');
                    const firstInput = form?.querySelector('input, textarea, select');
                    if (firstInput) firstInput.focus();
                    modal.addEventListener('click', (e) => { if (e.target === modal || e.target.closest('[data-action="close"]')) closeModal(); });
                    if (form && onSave) {
                        form.addEventListener('submit', (e) => {
                            e.preventDefault();
                            const formData = new FormData(form);
                            const shouldClose = onSave(formData); // onSave should return true to close
                            if (shouldClose) closeModal();
                        });
                    }
                    document.addEventListener('keydown', handleModalKeydown);
                 } else {
                    console.error("Modal container not found!");
                 }
             }
            function closeModal() { if (elements.modalContainer) elements.modalContainer.innerHTML = ''; document.removeEventListener('keydown', handleModalKeydown); }
            function handleModalKeydown(e) { if (e.key === 'Escape') closeModal(); }
            function openBulkEditModal(students) {
                 const commonGrade = getCommonValue(students, 'grade'); const commonDisability = getCommonValue(students, 'disabilityCategory');
                 const contentHTML = `<p class="text-sm mb-4 text-gray-600 dark:text-gray-400">Apply changes to ${students.length} selected students.</p><div class="space-y-4"><div><label class="form-label">Grade Level</label><select name="bulkGrade" class="form-select"><option value="">-- Keep Individual --</option>${Object.entries(GRADE_MAP).map(([c, n]) => `<option value="${c}" ${commonGrade === c ? 'selected' : ''}>${getGradeName(c)}</option>`).join('')}</select></div><div><label class="form-label">Disability Category</label><select name="bulkDisability" class="form-select"><option value="">-- Keep Individual --</option>${Object.entries(DISABILITY_MAP).map(([c, n]) => `<option value="${c}" ${commonDisability === c ? 'selected' : ''}>${n}</option>`).join('')}</select></div><div><label class="form-label">Append to Accommodations</label><textarea name="bulkAccommodation" rows="2" class="form-textarea" placeholder="Appends with '; ' separator..."></textarea></div><div><label class="form-label">Append to Services/Supports</label><textarea name="bulkServices" rows="2" class="form-textarea" placeholder="Appends with '; ' separator..."></textarea></div></div>`;
                 openModal("Bulk Edit Students", contentHTML, (formData) => {
                     const updates = { grade: formData.get('bulkGrade'), disabilityCategory: formData.get('bulkDisability'), specialAccommodations: formData.get('bulkAccommodation').trim(), servicesSupports: formData.get('bulkServices').trim() };
                     let changesMadeCount = 0;
                     students.forEach(student => {
                         let changed = false;
                         if (updates.grade) { student.grade = updates.grade; changed = true; }
                         if (updates.disabilityCategory) { student.disabilityCategory = updates.disabilityCategory; changed = true; }
                         if (updates.specialAccommodations) { student.specialAccommodations = appendText(student.specialAccommodations, updates.specialAccommodations); changed = true; }
                         if (updates.servicesSupports) { student.servicesSupports = appendText(student.servicesSupports, updates.servicesSupports); changed = true; }
                         if (changed) changesMadeCount++;
                     });
                     if (changesMadeCount > 0) { saveStateToLocalStorage(); updatePreview(); showToast(`Bulk edits applied to ${changesMadeCount} student(s).`, 'success'); } else { showToast(`No changes applied in bulk edit.`, 'info'); }
                     return true; // Close modal after applying
                 }, "Apply Changes");
             }
            function openProgressNoteModal(student, goal) {
                 const goalIndex = student.iepGoals.findIndex(g => g.id === goal.id);
                 if (goalIndex === -1) { showToast("Error finding goal.", 'error'); return; }
                 const contentHTML = `<p class="text-sm mb-4 text-gray-600 dark:text-gray-400">Goal ${goalIndex + 1} for ${student.name}.</p><div><label for="progressNote" class="form-label">Progress Note</label><textarea id="progressNote" name="progressNote" rows="4" class="form-textarea" required></textarea></div>`;
                 openModal("Add Progress Note", contentHTML, (formData) => {
                     const noteText = formData.get('progressNote').trim(); if (!noteText) { showToast("Note cannot be empty.", 'warning'); return false; } // Don't close if invalid
                     goal.progressNotes = goal.progressNotes || []; goal.progressNotes.push({ note: noteText, date: new Date().toISOString() });
                     saveStateToLocalStorage(); updatePreview(); showToast(`Progress note added to Goal ${goalIndex + 1}.`, 'success');
                     return true; // Close modal
                 }, "Add Note");
             }
            function openSettingsModal() {
                 // Added separate file inputs for CSV and JSON
                 const contentHTML = `<div class="space-y-5">
                    <div>
                        <label for="defaultModel" class="form-label">Default AI Model</label>
                        <select id="defaultModel" name="defaultModel" class="form-select">
                            <option value="gemini" ${appState.settings.defaultModel === 'gemini' ? 'selected' : ''}>Gemini Flash (Recommended)</option>
                            <option value="huggingface" ${appState.settings.defaultModel === 'huggingface' ? 'selected' : ''}>Hugging Face (Mistral)</option>
                        </select>
                    </div>
                    <div>
                        <label for="darkModeSetting" class="form-label">Theme</label>
                        <select id="darkModeSetting" name="darkModeSetting" class="form-select">
                            <option value="system" ${appState.settings.darkMode === 'system' ? 'selected' : ''}>System Default</option>
                            <option value="light" ${appState.settings.darkMode === 'light' ? 'selected' : ''}>Light</option>
                            <option value="dark" ${appState.settings.darkMode === 'dark' ? 'selected' : ''}>Dark</option>
                        </select>
                    </div>
                    <div class="pt-4 border-t dark:border-dark-300 space-y-2">
                        <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Data Management</h4>
                        <div class="flex flex-wrap gap-2">
                            <button type="button" id="exportJsonAllBtn" class="btn btn-secondary btn-sm">Backup All Data (JSON)</button>
                            <button type="button" id="importJsonBtn" class="btn btn-secondary btn-sm">Restore from Backup (JSON)</button>
                            <button type="button" id="exportCsvBtn" class="btn btn-secondary btn-sm">Export Students (CSV)</button>
                            <button type="button" id="importCsvBtn" class="btn btn-secondary btn-sm">Import Students (CSV)</button>
                        </div>
                        <input type="file" id="jsonFileInput" accept=".json" class="hidden">
                        <input type="file" id="csvFileInputModal" accept=".csv,text/csv" class="hidden">
                    </div>
                    <div class="pt-4 border-t border-danger-default/30">
                        <label class="form-label text-danger-default">Danger Zone</label>
                        <button type="button" id="clearStorageBtn" class="btn btn-danger w-full">Clear All Saved Data</button>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Warning: Deletes all students, groups, settings.</p>
                    </div>
                </div>`;
                 openModal("Settings", contentHTML, (formData) => {
                     appState.settings.defaultModel = formData.get('defaultModel');
                     appState.settings.darkMode = formData.get('darkModeSetting');
                     API_CONFIG.activeModel = appState.settings.defaultModel;
                     switchApiModel(API_CONFIG.activeModel, false);
                     applySettings();
                     saveStateToLocalStorage();
                     showToast('Settings saved.', 'success');
                     return true; // Close modal
                 }, "Save Settings");
                 // Add listeners for new buttons inside the modal
                 $('#exportJsonAllBtn')?.addEventListener('click', () => downloadJsonData('all'));
                 $('#importJsonBtn')?.addEventListener('click', () => $('#jsonFileInput')?.click());
                 $('#jsonFileInput')?.addEventListener('change', handleJsonUpload);
                 $('#exportCsvBtn')?.addEventListener('click', downloadCsvData);
                 $('#importCsvBtn')?.addEventListener('click', () => $('#csvFileInputModal')?.click());
                 $('#csvFileInputModal')?.addEventListener('change', handleCsvUpload); // Use handleCsvUpload
                 $('#clearStorageBtn')?.addEventListener('click', () => { if (confirm('DANGER: Clear ALL data? This cannot be undone.')) { localStorage.removeItem(STORAGE_KEY); window.location.reload(); } });
             }

            // --- Toast Notifications ---
            function showToast(message, type = 'info', duration = TOAST_DURATION) {
                if (!elements.toastContainer) return; // Safety check
                const toastId = `toast-${generateId()}`;
                const toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast toast-${type}`;
                toast.setAttribute('role', 'alert');
                const iconId = type === 'success' ? 'icon-check' : type === 'error' ? 'icon-error' : type === 'warning' ? 'icon-warning' : 'icon-info';
                toast.innerHTML = `<svg class="h-5 w-5"><use href="#${iconId}"/></svg><span>${escapeHtml(message)}</span>`;
                elements.toastContainer.appendChild(toast);

                // Auto-dismiss - ensure this always happens
                const timerId = setTimeout(() => {
                    const currentToast = $(`#${toastId}`);
                    if (currentToast) {
                        currentToast.classList.add('fade-out');
                        // Force remove after animation or after a fallback timeout
                        const removeToast = () => {
                            if (currentToast.parentNode) {
                                currentToast.remove();
                            }
                        };
                        currentToast.addEventListener('animationend', removeToast, { once: true });
                        // Fallback removal in case animation doesn't trigger properly
                        setTimeout(removeToast, 500);
                    }
                }, duration);

                // Manual dismiss
                toast.addEventListener('click', () => {
                    clearTimeout(timerId); // Prevent auto-dismiss if clicked
                    toast.classList.add('fade-out');
                    const removeOnClick = () => toast.remove();
                    toast.addEventListener('animationend', removeOnClick, { once: true });
                    // Fallback removal in case animation doesn't trigger
                    setTimeout(removeOnClick, 500);
                });
            }

            // --- Helper to append text safely ---
            function appendText(original, toAppend, separator = "; ") { if (!toAppend) return original; return original ? `${original.trim()}${separator}${toAppend}` : toAppend; }

        })(); // End IIFE
    </script>

    <!-- Add Tailwind form/button base styles -->
    <style>
        .form-label { display: block; font-size: 0.75rem; font-weight: 500; margin-bottom: 0.25rem; color: #4b5563; }
        .dark .form-label { color: #9ca3af; }
        .form-input, .form-textarea, .form-select, .form-select-multiple {
            display: block; width: 100%; padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem;
            background-color: #ffffff; color: #1f2937;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        .dark .form-input, .dark .form-textarea, .dark .form-select, .dark .form-select-multiple {
            background-color: #374151; border-color: #4b5563; color: #f3f4f6;
        }
        .form-input:focus, .form-textarea:focus, .form-select:focus, .form-select-multiple:focus {
            border-color: #5D5CDE; outline: 0; box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.3);
        }
        .form-textarea { min-height: 60px; }
        .form-select-multiple { padding: 0.5rem; } /* Adjust padding for multi-select */

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500;
            border: 1px solid transparent; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, color 0.2s, transform 0.1s;
            white-space: nowrap;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn:not(:disabled):active { transform: scale(0.98); }

        .btn-primary { background-color: #5D5CDE; color: white; border-color: #5D5CDE; }
        .btn-primary:hover:not(:disabled) { background-color: #4F46E5; border-color: #4F46E5; }
        .btn-primary-outline { background-color: transparent; color: #5D5CDE; border-color: #5D5CDE; }
        .btn-primary-outline:hover:not(:disabled) { background-color: rgba(93, 92, 222, 0.1); }

        .btn-secondary { background-color: #e5e7eb; color: #374151; border-color: #e5e7eb; }
        .dark .btn-secondary { background-color: #4b5563; color: #f3f4f6; border-color: #4b5563; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; border-color: #d1d5db; }
        .dark .btn-secondary:hover:not(:disabled) { background-color: #6b7280; border-color: #6b7280; }

        .btn-accent { background-color: #8B5CF6; color: white; border-color: #8B5CF6; }
        .btn-accent:hover:not(:disabled) { background-color: #7C3AED; border-color: #7C3AED; }

        .btn-success { background-color: #10B981; color: white; border-color: #10B981; }
        .btn-success:hover:not(:disabled) { background-color: #059669; border-color: #059669; }

        .btn-danger { background-color: #EF4444; color: white; border-color: #EF4444; }
        .btn-danger:hover:not(:disabled) { background-color: #DC2626; border-color: #DC2626; }
        .btn-danger-outline { background-color: transparent; color: #EF4444; border-color: #EF4444; }
        .btn-danger-outline:hover:not(:disabled) { background-color: rgba(239, 68, 68, 0.1); }

        .btn-link { background-color: transparent; border-color: transparent; color: #5D5CDE; text-decoration: underline; padding: 0.25rem; font-size: 0.75rem; }
        .btn-link:hover:not(:disabled) { color: #4F46E5; }

        .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
        .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.875rem; }

        .tab-btn { padding: 0.5rem 1rem; font-weight: 500; border-bottom: 2px solid transparent; color: #6b7280; cursor: pointer; transition: color 0.2s, border-color 0.2s; }
        .dark .tab-btn { color: #9ca3af; }
        .tab-btn.active { color: #5D5CDE; border-color: #5D5CDE; }
        .tab-btn:hover:not(.active) { color: #374151; border-color: #d1d5db; }
        .dark .tab-btn:hover:not(.active) { color: #f3f4f6; border-color: #4b5563; }

        .standard-item { padding: 0.5rem; border-radius: 0.375rem; cursor: pointer; transition: background-color 0.2s; border: 1px solid transparent; }
        .standard-item:hover:not([aria-disabled="true"]) { background-color: #f3f4f6; }
        .dark .standard-item:hover:not([aria-disabled="true"]) { background-color: #374151; }
        .standard-item:focus-visible { border-color: #8B5CF6; }
        .standard-item[aria-disabled="true"] { opacity: 0.5; cursor: not-allowed; }

        .suggestion-btn { font-size: 0.75rem; padding: 0.25rem 0.75rem; border-radius: 9999px; background-color: #e5e7eb; color: #374151; transition: background-color 0.2s; cursor: pointer; }
        .dark .suggestion-btn { background-color: #4b5563; color: #f3f4f6; }
        .suggestion-btn:hover { background-color: #d1d5db; }
        .dark .suggestion-btn:hover { background-color: #6b7280; }
    </style>
</body>
</html>
